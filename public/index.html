<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wingman: Goose</title>
    <link rel="icon" type="image/png" href="Wingman_Goose_Logo_Light.png" id="favicon-light">
    <link rel="icon" type="image/png" href="Wingman_Goose_Logo_Dark.png" id="favicon-dark" disabled>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- Force refresh timestamp: 2025-08-21-01:19 -->
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- iOS specific meta tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Wingman">
    <link rel="apple-touch-icon" href="Wingman_Goose_Logo_Light.png">
    
    <!-- Android/Chrome -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#059669">
    
    <!-- Windows -->
    <meta name="msapplication-TileColor" content="#059669">
    <meta name="msapplication-TileImage" content="Wingman_Goose_Logo_Light.png">
    
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* CSS Variables for theming */
        :root {
            /* Light theme (default) */
            --bg-gradient-start: #f9f9f9;
            --bg-gradient-end: #f5f5f0;
            --bg-primary: #ffffff;
            --bg-secondary: #fafaf9;
            --bg-tertiary: #f5f5f4;
            --text-primary: #1c1917;
            --text-secondary: #44403c;
            --text-tertiary: #57534e;
            --text-muted: #78716c;
            --text-disabled: #a8a29e;
            --border-primary: #e7e5e4;
            --border-secondary: #d6d3d1;
            --accent-primary: #059669;
            --accent-secondary: #047857;
            --accent-tertiary: #065f46;
            --accent-light: #d1fae5;
            --accent-bg: #f0fdf4;
            --code-bg: #1c1917;
            --code-text: #f5f5f4;
            --inline-code-bg: #f5f5f4;
            --inline-code-text: #dc2626;
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 2px 4px rgba(5, 150, 105, 0.2);
            --shadow-lg: 0 4px 8px rgba(5, 150, 105, 0.3);
        }

        /* Dark theme */
        body.dark-theme {
            --bg-gradient-start: #0a0a0a;
            --bg-gradient-end: #1c1917;
            --bg-primary: #1c1917;
            --bg-secondary: #292524;
            --bg-tertiary: #44403c;
            --text-primary: #f5f5f4;
            --text-secondary: #e7e5e4;
            --text-tertiary: #d6d3d1;
            --text-muted: #a8a29e;
            --text-disabled: #78716c;
            --border-primary: #44403c;
            --border-secondary: #57534e;
            --accent-primary: #10b981;
            --accent-secondary: #059669;
            --accent-tertiary: #34d399;
            --accent-light: #064e3b;
            --accent-bg: #022c22;
            --code-bg: #000000;
            --code-text: #f5f5f4;
            --inline-code-bg: #292524;
            --inline-code-text: #34d399;
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 2px 4px rgba(16, 185, 129, 0.2);
            --shadow-lg: 0 4px 8px rgba(16, 185, 129, 0.3);
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(to bottom, var(--bg-gradient-start), var(--bg-gradient-end));
            color: var(--text-tertiary);
            height: 100vh;
            display: flex;
            flex-direction: column;
            font-size: 14px;
            line-height: 1.5;
            transition: background 0.3s ease, color 0.3s ease;
        }
        
        .header {
            background: var(--bg-primary);
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            box-shadow: var(--shadow-sm);
            transition: all 0.3s ease;
        }
        
        .header h1 {
            color: var(--text-primary);
            font-size: 1.5rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .logo {
            width: 32px;
            height: 32px;
            object-fit: contain;
            transition: transform 0.2s ease;
        }

        .logo:hover {
            transform: scale(1.1);
        }

        /* Light theme logo visibility */
        .logo-light {
            display: inline;
        }

        .logo-dark {
            display: none;
        }

        /* Dark theme logo visibility */
        body.dark-theme .logo-light {
            display: none;
        }

        body.dark-theme .logo-dark {
            display: inline;
        }
        
        .header-right {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .connection-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--accent-primary);
            transition: background 0.3s ease;
            z-index: 1000;
        }
        
        .connection-bar.disconnected {
            background: #dc2626;
        }
        
        .goose-status {
            padding: 0.5rem 1rem;
            border-radius: 50px;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .goose-status:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }
        
        .provider-model-info {
            font-size: 0.875rem;
            color: var(--text-muted);
            margin-right: 1rem;
            display: flex;
            align-items: center;
        }
        
        .provider-model-info span {
            font-weight: 400;
        }
        
        /* Dark mode styling with green accent */
        body.dark-theme .provider-model-info {
            color: var(--accent-primary);
        }
        
        body.dark-theme .provider-model-info span {
            color: var(--accent-primary);
        }
        
        /* Dark mode header with pure black background for logo compatibility */
        body.dark-theme .header {
            background: #000000;
        }
        
        .session-count-badge {
            color: inherit;
            font-size: inherit;
            margin-left: 0;
            font-weight: inherit;
            display: inline;
        }

        .working-directory-display {
            font-size: 0.875rem;
            color: var(--text-muted);
            display: block;
            margin-top: 0.25rem;
            font-weight: 400;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 300px;
        }

        .working-directory-display:empty {
            display: none;
        }
        
        /* Dark mode styling with green accent */
        body.dark-theme .working-directory-display {
            color: var(--accent-primary);
        }
        
        .working-directory-info {
            font-size: 0.875rem;
            color: var(--text-muted);
            margin-right: 1rem;
            display: flex;
            align-items: center;
        }
        
        .working-directory-info span {
            font-weight: 400;
        }
        
        /* Dark mode styling with green accent */
        body.dark-theme .working-directory-info {
            color: var(--accent-primary);
        }
        
        body.dark-theme .working-directory-info span {
            color: var(--accent-primary);
        }
        
        .status-active {
            background: var(--accent-primary);
            color: white;
            box-shadow: var(--shadow-md);
        }
        
        .status-inactive {
            background: var(--text-disabled);
            color: white;
        }
        
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            max-width: 880px;
            margin: 0 auto;
            width: 100%;
            overflow: hidden;
            padding: 0 1rem;
        }
        
        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
            white-space: pre-wrap;
            word-wrap: break-word;
            background: var(--bg-primary);
            font-family: ui-monospace, SFMono-Regular, 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            line-height: 1.6;
            display: block;
            border-radius: 12px;
            margin: 1rem 0;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-primary);
            transition: all 0.3s ease;
        }
        
        .user-input {
            color: var(--accent-primary);
            font-weight: 600;
            background: var(--accent-bg);
            padding: 0.5rem 0.75rem;
            border-radius: 8px;
            margin: 0.5rem 0;
            border-left: 3px solid var(--accent-primary);
            display: block;
        }
        
        .system-output {
            color: var(--text-secondary);
        }
        
        .system-message {
            color: var(--text-disabled);
            font-style: italic;
            background: var(--bg-secondary);
            padding: 0.5rem 0.75rem;
            border-radius: 8px;
            margin: 0.5rem 0;
            border-left: 3px solid var(--border-secondary);
            display: block;
        }

        /* Markdown formatting */
        .system-output h1 {
            color: var(--accent-primary);
            font-size: 1.5em;
            margin: 1.5em 0 0.75em 0;
            font-weight: 600;
            border-bottom: 2px solid var(--accent-light);
            padding-bottom: 0.5em;
        }

        .system-output h2 {
            color: var(--accent-tertiary);
            font-size: 1.25em;
            margin: 1.25em 0 0.5em 0;
            font-weight: 600;
        }

        .system-output h3 {
            color: var(--accent-tertiary);
            font-size: 1.125em;
            margin: 1em 0 0.5em 0;
            font-weight: 600;
        }

        .system-output strong {
            color: var(--text-primary);
            font-weight: 600;
        }

        .system-output em {
            color: var(--text-muted);
            font-style: italic;
        }

        .system-output code {
            background: var(--inline-code-bg);
            color: var(--inline-code-text);
            padding: 0.25em 0.5em;
            border-radius: 6px;
            font-family: ui-monospace, SFMono-Regular, 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 0.875em;
            border: 1px solid var(--border-primary);
        }

        .system-output pre {
            background: var(--code-bg);
            color: var(--code-text);
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            border-left: 4px solid var(--accent-primary);
            overflow-x: auto;
            box-shadow: var(--shadow-sm);
        }

        .system-output pre code {
            background: none;
            padding: 0;
            color: inherit;
            border: none;
        }

        .system-output ul {
            margin: 1rem 0;
            padding-left: 1.5em;
        }

        .system-output li {
            margin: 0.5em 0;
            color: var(--text-secondary);
        }

        .system-output a {
            color: var(--accent-primary);
            text-decoration: underline;
            transition: color 0.2s ease;
        }

        .system-output a:hover {
            color: var(--accent-secondary);
        }
        
        .input-container {
            padding: 1rem 1.5rem;
            background: var(--bg-primary);
            border-top: 1px solid var(--border-primary);
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            flex-shrink: 0;
            transition: all 0.3s ease;
        }
        
        .input-row {
            display: flex;
            gap: 0.75rem;
            width: 100%;
        }
        
        .input-container input,
        .input-container textarea {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 0.875rem;
            font-family: inherit;
            transition: all 0.2s ease;
            resize: none;
            min-height: 3rem;
            max-height: calc(5 * 1.5em + 1.5rem);
            line-height: 1.5;
        }
        
        .input-container input:focus,
        .input-container textarea:focus {
            outline: none;
            border-color: var(--accent-primary);
            background: var(--bg-primary);
            box-shadow: 0 0 0 3px rgba(5, 150, 105, 0.1);
        }
        
        .input-container button {
            padding: 1rem 2rem;
            background: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            white-space: nowrap;
            font-family: inherit;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-md);
        }
        
        .input-container button:hover:not(:disabled) {
            background: var(--accent-secondary);
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
        }
        
        .input-container button:disabled {
            background: var(--text-disabled);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .interrupt-btn {
            padding: 0.75rem !important;
            background: var(--error-primary) !important;
            color: white !important;
            border: none !important;
            border-radius: 50% !important;
            cursor: pointer !important;
            font-size: 1rem !important;
            font-weight: 500 !important;
            width: 3rem !important;
            height: 3rem !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            transition: all 0.2s ease !important;
            box-shadow: var(--shadow-sm) !important;
        }

        .interrupt-btn:hover {
            background: #dc2626 !important;
            transform: scale(1.1) !important;
            box-shadow: var(--shadow-md) !important;
        }

        .interrupt-btn:active {
            transform: scale(0.95) !important;
            box-shadow: var(--shadow-sm) !important;
        }

        /* Spinner animation */
        .spinner {
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
        
        .btn-secondary {
            background: var(--bg-tertiary) !important;
            color: var(--text-primary) !important;
            border: 1px solid var(--border-secondary) !important;
            box-shadow: var(--shadow-sm) !important;
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: var(--accent-primary) !important;
            color: white !important;
            border-color: var(--accent-primary) !important;
            box-shadow: var(--shadow-md) !important;
        }
        
        .btn-danger {
            background: #dc2626 !important;
            color: white !important;
            border: 1px solid #dc2626 !important;
            box-shadow: 0 2px 4px rgba(220, 38, 38, 0.2) !important;
        }
        
        .btn-danger:hover:not(:disabled) {
            background: #b91c1c !important;
            border-color: #b91c1c !important;
            box-shadow: 0 4px 8px rgba(220, 38, 38, 0.3) !important;
            transform: translateY(-1px);
        }

        .btn-settings {
            background: var(--bg-tertiary) !important;
            color: var(--text-secondary) !important;
            border: 1px solid var(--border-primary) !important;
            font-size: 1.2rem;
            padding: 0.75rem;
            min-width: 50px;
            border-radius: 50px;
            transition: all 0.2s ease;
        }

        .btn-settings:hover:not(:disabled) {
            background: var(--accent-primary) !important;
            color: white !important;
            transform: translateY(-1px);
            box-shadow: var(--shadow-md) !important;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 1rem;
            color: var(--text-muted);
            font-style: italic;
        }
        
        .goose-command-input {
            background: var(--bg-tertiary) !important;
            border-color: var(--text-disabled) !important;
            font-family: ui-monospace, SFMono-Regular, 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace !important;
            padding: 1rem 1.25rem !important;
            font-size: 0.95rem !important;
        }
        
        .session-controls {
            display: flex;
            gap: 0.75rem;
            margin-top: 0.75rem;
        }
        
        .session-name-input {
            flex: 1;
            padding: 1rem 1.25rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            color: var(--text-primary);
            border-radius: 8px;
            font-family: inherit;
            font-size: 0.95rem;
            transition: all 0.2s ease;
        }

        .session-name-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            background: var(--bg-primary);
            box-shadow: 0 0 0 3px rgba(5, 150, 105, 0.1);
        }

        /* Scrollbar styling */
        .messages::-webkit-scrollbar {
            width: 8px;
        }
        
        .messages::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 4px;
        }
        
        .messages::-webkit-scrollbar-thumb {
            background: var(--border-secondary);
            border-radius: 4px;
        }
        
        .messages::-webkit-scrollbar-thumb:hover {
            background: var(--text-disabled);
        }

        /* Theme toggle button */
        .theme-toggle {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 50px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 50px;
        }

        .theme-toggle:hover {
            background: var(--accent-primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .theme-icon-light {
            display: inline;
        }

        .theme-icon-dark {
            display: none;
        }

        body.dark-theme .theme-icon-light {
            display: none;
        }

        body.dark-theme .theme-icon-dark {
            display: inline;
        }

        /* Session Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        /* Higher z-index for wizard modals */
        .modal-overlay.wizard-modal {
            z-index: 1100;
        }

        /* Highest z-index for nested modals like directory browser */
        .modal-overlay.nested-modal {
            z-index: 1200;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: var(--bg-primary);
            border-radius: 12px;
            padding: 1.5rem;
            max-width: 800px;
            width: 95%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-primary);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-primary);
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0.25rem;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .session-list {
            margin-bottom: 1rem;
        }

        .session-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid var(--border-primary);
        }

        .session-item:hover {
            background: var(--accent-light);
            border-color: var(--accent-primary);
            transform: translateY(-1px);
        }

        .session-info {
            flex: 1;
        }

        .session-name {
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
        }

        .session-date {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .session-actions {
            display: flex;
            gap: 0.5rem;
        }

        .btn-small {
            padding: 0.375rem 0.75rem;
            font-size: 0.8rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .btn-resume {
            background: var(--accent-primary);
            color: white;
        }

        .btn-resume:hover {
            background: var(--accent-secondary);
            transform: translateY(-1px);
        }

        /* Recipe Summary Styles */
        .selected-recipe-summary {
            border: 1px solid var(--accent-primary);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            background: var(--accent-bg);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
        }

        .recipe-info {
            flex: 1;
        }

        .recipe-info strong {
            color: var(--text-primary);
        }

        .recipe-info p {
            color: var(--text-secondary);
            margin: 0.5rem 0 0 0;
            font-size: 0.9rem;
        }

        .recipe-actions {
            display: flex;
            gap: 0.5rem;
            flex-shrink: 0;
        }

        /* Recipe Selector Modal Styles */
        .recipe-selector-content {
            margin-bottom: 1.5rem;
        }

        .recipe-preview-panel {
            border-top: 1px solid var(--border-primary);
            padding-top: 1.5rem;
            margin-top: 1.5rem;
        }

        .preview-content {
            margin-bottom: 1rem;
        }

        .preview-content h5 {
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .preview-content p {
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .preview-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }

        .recipe-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-primary);
            margin-bottom: 1rem;
        }

        .recipe-tab {
            background: none;
            border: none;
            padding: 0.5rem 1rem;
            cursor: pointer;
            color: var(--text-secondary);
            border-bottom: 2px solid transparent;
            transition: all 0.2s ease;
        }

        .recipe-tab.active {
            color: var(--accent-primary);
            border-bottom-color: var(--accent-primary);
        }

        .recipe-tab:hover {
            color: var(--text-primary);
        }

        .recipe-tab-content {
            display: none;
        }

        .recipe-tab-content.active {
            display: block;
        }

        .recipe-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .recipe-card {
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            padding: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            background: var(--bg-secondary);
        }

        .recipe-card:hover {
            border-color: var(--accent-primary);
            background: var(--accent-bg);
        }

        .recipe-card.selected {
            border-color: var(--accent-primary);
            background: var(--accent-light);
        }

        .recipe-card-title {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
            font-size: 0.9rem;
        }

        .recipe-card-description {
            color: var(--text-secondary);
            font-size: 0.8rem;
            line-height: 1.3;
            margin-bottom: 0.5rem;
        }

        .recipe-card-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
        }

        .recipe-tag {
            background: var(--accent-light);
            color: var(--accent-tertiary);
            padding: 0.125rem 0.375rem;
            border-radius: 3px;
            font-size: 0.7rem;
        }

        .category-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .category-button {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 20px;
            padding: 0.375rem 0.75rem;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .category-button:hover {
            background: var(--accent-light);
            border-color: var(--accent-primary);
            color: var(--accent-tertiary);
        }

        .category-button.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        .selected-recipe {
            border: 1px solid var(--accent-primary);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            background: var(--accent-bg);
        }

        .selected-recipe h4 {
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .selected-recipe p {
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .recipe-parameters {
            margin-bottom: 1rem;
        }

        .parameter-input {
            margin-bottom: 0.75rem;
        }

        .parameter-label {
            display: block;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
            font-size: 0.9rem;
        }

        .parameter-description {
            color: var(--text-muted);
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
        }

        .search-box {
            margin-bottom: 1rem;
        }

        .search-box input {
            width: 100%;
        }

        /* Responsive adjustments for session modal */
        @media (max-width: 768px) {
            .modal {
                max-width: 95%;
                width: 95%;
                padding: 1rem;
                max-height: 90vh;
            }
            
            .recipe-grid {
                grid-template-columns: 1fr;
                max-height: 250px;
            }
            
            .recipe-selector {
                padding: 1rem;
                min-height: 300px;
            }
        }

        .btn-delete {
            background: #dc2626;
            color: white;
        }

        .btn-delete:hover {
            background: #b91c1c;
            transform: translateY(-1px);
        }

        .new-session-section {
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-primary);
            margin-bottom: 1rem;
        }

        .new-session-form {
            display: flex;
            gap: 0.75rem;
            align-items: end;
        }

        .form-group {
            flex: 1;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 0.875rem;
            transition: all 0.2s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            background: var(--bg-primary);
            box-shadow: 0 0 0 3px rgba(5, 150, 105, 0.1);
        }

        .empty-sessions {
            text-align: center;
            padding: 2rem;
            color: var(--text-muted);
            font-style: italic;
        }

        /* Directory Selector Styles */
        .directory-selector {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .directory-selector input {
            flex: 1;
        }

        .directory-browser {
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            background: var(--bg-primary);
            max-height: 300px;
            overflow-y: auto;
            margin-top: 0.5rem;
        }

        .directory-item {
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: background 0.2s ease;
            border-bottom: 1px solid var(--border-primary);
        }

        .directory-item:last-child {
            border-bottom: none;
        }

        .directory-item:hover {
            background: var(--accent-light);
        }

        .directory-item.selected {
            background: var(--accent-light);
            color: var(--accent-tertiary);
        }

        .directory-icon {
            font-size: 1rem;
            width: 1.2rem;
            text-align: center;
        }

        .current-path {
            padding: 0.5rem 0.75rem;
            background: var(--bg-secondary);
            font-family: monospace;
            font-size: 0.8rem;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border-primary);
        }

        /* Wizard Styles */
        .wizard-step {
            padding: 1rem 0;
        }

        .wizard-step h4 {
            color: var(--text-primary);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-primary);
        }

        .wizard-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .wizard-nav {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-primary);
            display: flex;
            justify-content: flex-start;
        }

        /* Settings Modal */
        .settings-section {
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-primary);
        }

        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .setting-control {
            margin-bottom: 1rem;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            cursor: pointer;
            margin-bottom: 0.5rem;
        }

        .checkbox-container input[type="checkbox"] {
            opacity: 0;
            position: absolute;
            width: 0;
            height: 0;
        }

        .checkmark {
            width: 20px;
            height: 20px;
            background-color: var(--bg-secondary);
            border: 2px solid var(--border-secondary);
            border-radius: 4px;
            margin-right: 0.75rem;
            position: relative;
            transition: all 0.2s ease;
        }

        .checkbox-container:hover .checkmark {
            border-color: var(--accent-primary);
        }

        .checkbox-container input[type="checkbox"]:checked + .checkmark {
            background-color: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        .checkbox-container input[type="checkbox"]:checked + .checkmark:after {
            content: "";
            position: absolute;
            left: 6px;
            top: 2px;
            width: 6px;
            height: 10px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }

        .setting-label {
            font-weight: 500;
            color: var(--text-primary);
        }

        .setting-description {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-left: 2.75rem;
            line-height: 1.4;
        }

        .settings-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 1rem;
        }

        .button-group {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }
        
        .button-group button {
            padding: 1rem 1.5rem;
            font-size: 0.9rem;
            min-height: 48px;
        }

        .command-controls {
            display: flex;
            gap: 1rem;
            align-items: end;
        }

        .command-controls input {
            flex: 1;
        }
        
        .command-controls button {
            padding: 1rem 1.5rem;
            font-size: 0.9rem;
            min-height: 48px;
        }

        .action-controls {
            display: flex;
            gap: 1rem;
        }
        
        .action-controls button {
            padding: 1rem 1.5rem;
            font-size: 0.9rem;
            min-height: 48px;
        }

        /* Mobile hamburger menu */
        .mobile-menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 8px;
            transition: background 0.2s ease;
            color: var(--text-primary);
        }

        .mobile-menu-toggle:hover {
            background: var(--bg-tertiary);
        }

        .mobile-menu {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-primary);
            box-shadow: var(--shadow-lg);
            transform: translateY(-100%);
            transition: transform 0.3s ease;
            z-index: 1001;
            padding: 1rem 1.5rem;
            display: block;
        }

        .mobile-menu.show {
            transform: translateY(0);
        }

        .mobile-menu-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-primary);
        }

        .mobile-menu-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 8px;
            transition: background 0.2s ease;
            color: var(--text-primary);
        }

        .mobile-menu-close:hover {
            background: var(--bg-tertiary);
        }

        .mobile-menu-items {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .mobile-menu-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            border-radius: 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
        }

        .mobile-menu-item.session-only {
            justify-content: center;
        }

        .mobile-menu-label {
            font-weight: 500;
            color: var(--text-primary);
        }

        /* Desktop and Mobile menu responsiveness */
        @media (min-width: 769px) {
            /* Desktop: Show mobile menu toggle, keep header-right visible */
            .mobile-menu-toggle {
                display: block;
            }
        }

        @media (max-width: 768px) {
            /* Mobile: Show mobile menu toggle */
            .mobile-menu-toggle {
                display: block;
            }

            /* Hide session status on mobile - it's in hamburger menu */
            #gooseStatus {
                display: none;
            }
            #providerModelInfo {
                display: none !important;
            }

            /* Re-enable send button on mobile */
            .input-container button#sendBtn {
                display: block;
            }

            /* Mobile textarea height limit (3 lines) */
            .input-container textarea {
                max-height: calc(3 * 1.5em + 1.5rem);
            }

            /* Adjust chat container padding */
            .chat-container {
                padding: 0 0.75rem;
            }

            /* Adjust input container for mobile */
            .input-container {
                padding: 1rem;
            }

            /* Make status display full width in mobile menu */
            .mobile-menu-item .goose-status {
                margin: 0;
                flex: 1;
                text-align: center;
            }

            /* Adjust header padding */
            .header {
                padding: 1rem;
            }

            /* Smaller logo on mobile */
            .logo {
                width: 28px;
                height: 28px;
            }

            .header h1 {
                font-size: 1.25rem;
            }

            /* Settings button in mobile menu */
            .mobile-settings-btn {
                background: var(--accent-primary);
                color: white;
                border: 1px solid var(--accent-primary);
                padding: 0.75rem 1.5rem;
                border-radius: 8px;
                cursor: pointer;
                font-size: 0.875rem;
                font-weight: 500;
                transition: all 0.2s ease;
                width: 100%;
                box-shadow: var(--shadow-sm);
            }

            .mobile-settings-btn:hover {
                background: var(--accent-secondary);
                border-color: var(--accent-secondary);
                transform: translateY(-1px);
                box-shadow: var(--shadow-md);
            }
        }
    </style>
</head>
<body>
    <div id="connectionBar" class="connection-bar"></div>
    <div class="header">
        <h1>
            <img src="Wingman_Goose_Logo_Light.png" alt="Wingman Goose" class="logo logo-light">
            <img src="Wingman_Goose_Logo_Dark.png" alt="Wingman Goose" class="logo logo-dark">
            Wingman: Goose
        </h1>
        <div class="header-right">
            <div id="providerModelInfo" class="provider-model-info" style="display: none;">
                <span id="providerModelText"></span>
            </div>
            <div id="workingDirectoryInfo" class="working-directory-info" style="display: none;">
                <div id="workingDirectoryDisplay" class="working-directory-display"></div>
            </div>
            <div id="gooseStatus" class="goose-status status-inactive">
                <span id="sessionNameDisplay">No Session Active</span>
                <span id="sessionCountBadge" class="session-count-badge" style="display: none;"></span>
            </div>
            <button id="mobileMenuToggle" class="mobile-menu-toggle" aria-label="Open menu">
                ‚ò∞
            </button>
            <!-- Hidden elements for desktop use -->
            <a href="/recipes" class="btn-settings" aria-label="Recipe Manager" style="display: none; text-decoration: none;">üìã</a>
            <button id="settingsBtn" class="btn-settings" aria-label="Settings" style="display: none;">‚öôÔ∏è</button>
            <button id="themeToggle" class="theme-toggle" aria-label="Toggle theme" style="display: none;">
                <span class="theme-icon-light">‚òÄÔ∏è</span>
                <span class="theme-icon-dark">üåô</span>
            </button>
        </div>
    </div>
    
    <!-- Mobile Menu -->
    <div id="mobileMenu" class="mobile-menu">
        <div class="mobile-menu-header">
            <h3 style="color: var(--text-primary); margin: 0;">Menu</h3>
            <button id="mobileMenuClose" class="mobile-menu-close" aria-label="Close menu">
                √ó
            </button>
        </div>
        
        <div class="mobile-menu-items">
            <!-- Session Status -->
            <div class="mobile-menu-item session-only">
                <div id="mobileGooseStatus" class="goose-status status-inactive">
                    <span id="mobileSessionNameDisplay">No Session Active</span>
                </div>
            </div>
            
            <!-- Provider/Model Info -->
            <div id="mobileProviderModelInfo" class="mobile-menu-item session-only" style="display: none;">
                <div class="provider-model-info">
                    <span id="mobileProviderModelText"></span>
                </div>
            </div>
            
            <!-- Working Directory Info -->
            <div id="mobileWorkingDirectoryInfo" class="mobile-menu-item session-only" style="display: none;">
                <div class="working-directory-info">
                    <div id="mobileWorkingDirectoryDisplay" class="working-directory-display"></div>
                </div>
            </div>
            
            <!-- Recipe Manager -->
            <div class="mobile-menu-item">
                <a href="/recipes" style="text-decoration: none; color: inherit; width: 100%; display: block;">
                    üìã Recipe Manager
                </a>
            </div>
            
            <!-- Theme Toggle -->
            <div class="mobile-menu-item">
                <span class="mobile-menu-label">Theme</span>
                <button id="mobileThemeToggle" class="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon-light">‚òÄÔ∏è Light</span>
                    <span class="theme-icon-dark">üåô Dark</span>
                </button>
            </div>
            
            <!-- Settings -->
            <div class="mobile-menu-item">
                <span id="mobileSettingsBtn" class="mobile-settings-btn" style="cursor: pointer; color: inherit; background: none; border: none; width: 100%; text-align: left;">
                    ‚öôÔ∏è Settings
                </span>
            </div>
        </div>
    </div>

    <!-- Recipe Selector Modal -->
    <div id="recipeSelectorModal" class="modal-overlay nested-modal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Choose a Recipe</h3>
                <button class="modal-close" id="closeRecipeSelectorModal">√ó</button>
            </div>
            
            <div class="recipe-selector-content">
                <div class="recipe-tabs">
                    <button class="recipe-tab active" data-tab="popular">Popular</button>
                    <button class="recipe-tab" data-tab="categories">Categories</button>
                    <button class="recipe-tab" data-tab="search">Search</button>
                </div>
                
                <div id="popular-recipes" class="recipe-tab-content active">
                    <div class="recipe-grid" id="popularRecipeGrid">
                        <!-- Popular recipes will be loaded here -->
                    </div>
                </div>
                
                <div id="category-recipes" class="recipe-tab-content">
                    <div class="category-list" id="categoryList">
                        <!-- Categories will be loaded here -->
                    </div>
                    <div class="recipe-grid" id="categoryRecipeGrid">
                        <!-- Category recipes will be loaded here -->
                    </div>
                </div>
                
                <div id="search-recipes" class="recipe-tab-content">
                    <div class="search-box">
                        <input type="text" id="recipeSearchInput" class="form-input" placeholder="Search recipes...">
                    </div>
                    <div class="recipe-grid" id="searchRecipeGrid">
                        <!-- Search results will be loaded here -->
                    </div>
                </div>
            </div>

            <!-- Recipe Preview Panel -->
            <div id="recipePreviewPanel" class="recipe-preview-panel" style="display: none;">
                <h4>Recipe Preview</h4>
                <div class="preview-content">
                    <h5 id="previewRecipeName"></h5>
                    <p id="previewRecipeDescription"></p>
                    <div id="previewRecipeParameters"></div>
                </div>
                <div class="preview-actions">
                    <button id="confirmRecipeSelection" class="btn btn-primary">Select This Recipe</button>
                    <button id="cancelRecipePreview" class="btn btn-secondary">Back</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Directory Browser Modal -->
    <div id="directoryBrowserModal" class="modal-overlay nested-modal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Select Working Directory</h3>
                <button class="modal-close" id="closeDirectoryBrowserModal">√ó</button>
            </div>
            
            <div class="current-path" id="currentPath">/</div>
            
            <div class="directory-browser" id="directoryBrowser">
                <div class="loading" style="padding: 2rem; text-align: center;">Loading directories...</div>
            </div>
            
            <div style="margin-top: 1rem; display: flex; gap: 1rem; justify-content: flex-end;">
                <button id="selectDirectoryBtn" class="btn btn-primary">Select This Directory</button>
                <button id="cancelDirectorySelection" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>
    
    <div class="chat-container">
        <div class="messages" id="messages"></div>
        <div class="loading" id="loading">Goose is thinking...</div>
        
        <div class="input-container">
            <div class="input-row">
                <textarea id="messageInput" placeholder="Type your message to Goose... (Shift+Enter for new line)" maxlength="5000" rows="1"></textarea>
                <button id="interruptBtn" class="interrupt-btn" title="Stop current operation (Ctrl+C)" style="display: none;">
                    <span class="spinner"></span>
                </button>
                <button id="sendBtn">Send</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal-overlay">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Settings</h3>
                <button class="modal-close" id="closeSettingsModal">√ó</button>
            </div>
            
            
            <div class="settings-section">
                <h4 class="settings-title">Goose Commands</h4>
                <div class="command-controls">
                    <input type="text" id="commandInput" class="goose-command-input" placeholder="Goose command (e.g., /help, /mode chat, /plan task)">
                    <button id="sendCommandBtn" class="btn-secondary">Send Command</button>
                </div>
            </div>
            
            <div class="settings-section">
                <h4 class="settings-title">Interruption Behavior</h4>
                <div class="setting-control">
                    <label class="checkbox-container">
                        <input type="checkbox" id="enableInterruptOnNewMessage" checked>
                        <span class="checkmark"></span>
                        <span class="setting-label">Interrupt on new message</span>
                    </label>
                    <div class="setting-description">
                        When enabled, sending a new message while Goose is processing will automatically interrupt the current operation (like pressing Ctrl+C).
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <h4 class="settings-title">Actions</h4>
                <div class="action-controls">
                    <button id="clearBtn" class="btn-danger">Clear Conversation</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Session Modal -->
    <div id="sessionModal" class="modal-overlay">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Goose Sessions</h3>
                <button class="modal-close" id="closeModal">√ó</button>
            </div>
            
            <div class="new-session-section">
                <div class="new-session-form">
                    <div class="form-group">
                        <label class="form-label" for="newSessionName">Session Name</label>
                        <input type="text" id="newSessionName" class="form-input" placeholder="Enter session name (optional)">
                    </div>
                    
                    <div class="button-group">
                        <button id="createNewSessionBtn" class="btn btn-primary">Create New Session</button>
                    </div>
                </div>
            </div>
            
            <div class="form-group" style="margin: 1rem 0;">
                <label class="form-label" for="sessionSearchFilter">Search Sessions</label>
                <input type="text" id="sessionSearchFilter" class="form-input" placeholder="Type to filter sessions...">
            </div>
            
            <div class="session-list" id="sessionList">
                <!-- Sessions will be populated here -->
            </div>
        </div>
    </div>

    <!-- Session Creation Wizard -->
    <div id="sessionWizardModal" class="modal-overlay wizard-modal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title" id="wizardTitle">Create New Session</h3>
                <button class="modal-close" id="closeWizardModal">√ó</button>
            </div>
            
            <!-- Step 1: Session Name -->
            <div id="wizardStep1" class="wizard-step">
                <h4>Step 1: Session Name</h4>
                <div class="form-group">
                    <label class="form-label" for="wizardSessionName">Session Name</label>
                    <input type="text" id="wizardSessionName" class="form-input" placeholder="Enter session name (optional)">
                </div>
                <div class="wizard-buttons">
                    <button id="wizardStep1Next" class="btn btn-primary">Next: Choose Recipe</button>
                </div>
            </div>
            
            <!-- Step 2: Recipe Selection -->
            <div id="wizardStep2" class="wizard-step" style="display: none;">
                <h4>Step 2: Recipe Selection</h4>
                <p style="margin-bottom: 1rem; color: var(--text-secondary);">Would you like to use a recipe for this session?</p>
                
                <div id="selectedRecipeWizard" class="selected-recipe-summary" style="display: none;">
                    <div class="recipe-info">
                        <strong>Selected Recipe:</strong> <span id="wizardSelectedRecipeName"></span>
                        <p id="wizardSelectedRecipeDescription"></p>
                    </div>
                </div>
                
                <div class="wizard-buttons">
                    <button id="wizardChooseRecipeBtn" class="btn btn-secondary">üìã Choose Recipe</button>
                    <button id="wizardSkipRecipeBtn" class="btn btn-secondary">Skip (Default)</button>
                    <button id="wizardStep2Next" class="btn btn-primary" disabled>Next: Working Directory</button>
                </div>
                <div class="wizard-nav">
                    <button id="wizardStep2Back" class="btn btn-secondary">‚Üê Back</button>
                </div>
            </div>
            
            <!-- Step 2.5: Provider/Model Override (only shown when recipe is selected) -->
            <div id="wizardStep2_5" class="wizard-step" style="display: none;">
                <h4>Step 2.5: Provider/Model Override</h4>
                <p style="margin-bottom: 1rem; color: var(--text-secondary);">Optionally override the provider/model for this session.</p>
                
                <div id="recipeDefaultsDisplay" class="recipe-defaults-info" style="margin-bottom: 1rem; padding: 1rem; background: var(--bg-secondary); border-radius: 0.5rem;">
                    <strong>Recipe Defaults:</strong>
                    <p id="recipeDefaultProvider">Provider: <span>-</span></p>
                    <p id="recipeDefaultModel">Model: <span>-</span></p>
                </div>
                
                <div class="form-group">
                    <label for="enableProviderOverride" class="form-label">
                        <input type="checkbox" id="enableProviderOverride" style="margin-right: 0.5rem;">
                        Override provider/model for this session
                    </label>
                </div>
                
                <div id="providerOverrideControls" style="display: none;">
                    <div class="form-group">
                        <label class="form-label" for="overrideProvider">Provider</label>
                        <select id="overrideProvider" class="form-input">
                            <option value="">Use Recipe/Goose Default</option>
                        </select>
                    </div>
                    
                    <div class="form-group" id="overrideModelGroup" style="display: none;">
                        <label class="form-label" for="overrideModel">Model</label>
                        <select id="overrideModel" class="form-input">
                            <option value="">Use Provider Default</option>
                        </select>
                    </div>
                </div>
                
                <div class="wizard-buttons">
                    <button id="wizardStep2_5Next" class="btn btn-primary">Next: Working Directory</button>
                </div>
                <div class="wizard-nav">
                    <button id="wizardStep2_5Back" class="btn btn-secondary">‚Üê Back</button>
                </div>
            </div>
            
            <!-- Step 3: Working Directory -->
            <div id="wizardStep3" class="wizard-step" style="display: none;">
                <h4>Step 3: Working Directory</h4>
                <p style="margin-bottom: 1rem; color: var(--text-secondary);">Choose the directory where Goose should run.</p>
                
                <div class="form-group">
                    <label class="form-label" for="wizardWorkingDirectory">Working Directory</label>
                    <div class="directory-selector">
                        <input type="text" id="wizardWorkingDirectory" class="form-input" readonly>
                        <button type="button" id="wizardBrowseDirectoryBtn" class="btn-small btn-secondary">üìÅ Browse</button>
                    </div>
                </div>
                
                <div class="wizard-buttons">
                    <button id="wizardUseCurrentDirBtn" class="btn btn-secondary">Use Current Directory</button>
                    <button id="wizardCreateSessionBtn" class="btn btn-primary">Create Session</button>
                </div>
                <div class="wizard-nav">
                    <button id="wizardStep3Back" class="btn btn-secondary">‚Üê Back</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        class GooseStreamingApp {
            constructor() {
                this.socket = io();
                this.messagesDiv = document.getElementById('messages');
                this.messageInput = document.getElementById('messageInput');
                this.sendBtn = document.getElementById('sendBtn');
                this.interruptBtn = document.getElementById('interruptBtn');
                this.clearBtn = document.getElementById('clearBtn');
                this.loading = document.getElementById('loading');
                this.connectionBar = document.getElementById('connectionBar');
                this.gooseStatus = document.getElementById('gooseStatus');
                this.sessionNameDisplay = document.getElementById('sessionNameDisplay');
                this.workingDirectoryDisplay = document.getElementById('workingDirectoryDisplay');
                this.sessionCountBadge = document.getElementById('sessionCountBadge');
                
                // New provider/model display elements
                this.providerModelInfo = document.getElementById('providerModelInfo');
                this.providerModelText = document.getElementById('providerModelText');
                this.mobileProviderModelInfo = document.getElementById('mobileProviderModelInfo');
                this.mobileProviderModelText = document.getElementById('mobileProviderModelText');
                
                // Working directory display elements
                this.workingDirectoryInfo = document.getElementById('workingDirectoryInfo');
                this.mobileWorkingDirectoryInfo = document.getElementById('mobileWorkingDirectoryInfo');
                this.mobileWorkingDirectoryDisplay = document.getElementById('mobileWorkingDirectoryDisplay');
                
                // Session search filter
                this.sessionSearchFilter = document.getElementById('sessionSearchFilter');
                
                this.sessionNameInput = document.getElementById('sessionNameInput');
                this.startSessionBtn = document.getElementById('startSessionBtn');
                this.stopSessionBtn = document.getElementById('stopSessionBtn');
                this.listSessionsBtn = document.getElementById('listSessionsBtn');
                
                this.commandInput = document.getElementById('commandInput');
                this.sendCommandBtn = document.getElementById('sendCommandBtn');
                
                this.themeToggle = document.getElementById('themeToggle');
                
                // Modal elements
                this.sessionModal = document.getElementById('sessionModal');
                this.sessionList = document.getElementById('sessionList');
                this.closeModal = document.getElementById('closeModal');
                this.newSessionName = document.getElementById('newSessionName');
                this.createNewSessionBtn = document.getElementById('createNewSessionBtn');
                
                // Wizard elements
                this.sessionWizardModal = document.getElementById('sessionWizardModal');
                this.closeWizardModal = document.getElementById('closeWizardModal');
                this.wizardStep1 = document.getElementById('wizardStep1');
                this.wizardStep2 = document.getElementById('wizardStep2');
                this.wizardStep2_5 = document.getElementById('wizardStep2_5');
                this.wizardStep3 = document.getElementById('wizardStep3');
                this.wizardSessionName = document.getElementById('wizardSessionName');
                this.wizardWorkingDirectory = document.getElementById('wizardWorkingDirectory');
                
                // Wizard buttons
                this.wizardStep1Next = document.getElementById('wizardStep1Next');
                this.wizardStep2Back = document.getElementById('wizardStep2Back');
                this.wizardStep2Next = document.getElementById('wizardStep2Next');
                this.wizardStep2_5Back = document.getElementById('wizardStep2_5Back');
                this.wizardStep2_5Next = document.getElementById('wizardStep2_5Next');
                this.wizardStep3Back = document.getElementById('wizardStep3Back');
                this.wizardChooseRecipeBtn = document.getElementById('wizardChooseRecipeBtn');
                this.wizardSkipRecipeBtn = document.getElementById('wizardSkipRecipeBtn');
                this.wizardBrowseDirectoryBtn = document.getElementById('wizardBrowseDirectoryBtn');
                this.wizardUseCurrentDirBtn = document.getElementById('wizardUseCurrentDirBtn');
                this.wizardCreateSessionBtn = document.getElementById('wizardCreateSessionBtn');
                
                // Provider/Model override elements
                this.enableProviderOverride = document.getElementById('enableProviderOverride');
                this.providerOverrideControls = document.getElementById('providerOverrideControls');
                this.overrideProvider = document.getElementById('overrideProvider');
                this.overrideModel = document.getElementById('overrideModel');
                this.overrideModelGroup = document.getElementById('overrideModelGroup');
                this.recipeDefaultProvider = document.getElementById('recipeDefaultProvider');
                this.recipeDefaultModel = document.getElementById('recipeDefaultModel');
                
                // Wizard recipe elements
                this.selectedRecipeWizard = document.getElementById('selectedRecipeWizard');
                this.wizardSelectedRecipeName = document.getElementById('wizardSelectedRecipeName');
                this.wizardSelectedRecipeDescription = document.getElementById('wizardSelectedRecipeDescription');
                
                // Settings modal elements
                this.settingsModal = document.getElementById('settingsModal');
                this.settingsBtn = document.getElementById('settingsBtn');
                this.closeSettingsModal = document.getElementById('closeSettingsModal');
                this.enableInterruptOnNewMessage = document.getElementById('enableInterruptOnNewMessage');
                
                // Mobile menu elements
                this.mobileMenu = document.getElementById('mobileMenu');
                this.mobileMenuToggle = document.getElementById('mobileMenuToggle');
                this.mobileMenuClose = document.getElementById('mobileMenuClose');
                this.mobileGooseStatus = document.getElementById('mobileGooseStatus');
                this.mobileSessionNameDisplay = document.getElementById('mobileSessionNameDisplay');
                this.mobileWorkingDirectoryDisplay = document.getElementById('mobileWorkingDirectoryDisplay');
                this.mobileThemeToggle = document.getElementById('mobileThemeToggle');
                this.mobileSettingsBtn = document.getElementById('mobileSettingsBtn');
                
                // Recipe selection elements
                this.recipeSelectorModal = document.getElementById('recipeSelectorModal');
                this.selectRecipeBtn = document.getElementById('selectRecipeBtn');
                this.changeRecipeBtn = document.getElementById('changeRecipeBtn');
                this.closeRecipeSelectorModal = document.getElementById('closeRecipeSelectorModal');
                
                this.recipeTabs = document.querySelectorAll('.recipe-tab');
                this.recipeTabContents = document.querySelectorAll('.recipe-tab-content');
                this.popularRecipeGrid = document.getElementById('popularRecipeGrid');
                this.categoryList = document.getElementById('categoryList');
                this.categoryRecipeGrid = document.getElementById('categoryRecipeGrid');
                this.searchRecipeGrid = document.getElementById('searchRecipeGrid');
                this.recipeSearchInput = document.getElementById('recipeSearchInput');
                
                this.selectedRecipeDisplay = document.getElementById('selectedRecipeDisplay');
                this.selectedRecipeName = document.getElementById('selectedRecipeName');
                this.selectedRecipeDescription = document.getElementById('selectedRecipeDescription');
                this.clearRecipeSelection = document.getElementById('clearRecipeSelection');
                
                // Directory browser elements
                this.workingDirectory = document.getElementById('workingDirectory');
                this.browseDirectoryBtn = document.getElementById('browseDirectoryBtn');
                this.directoryBrowserModal = document.getElementById('directoryBrowserModal');
                this.closeDirectoryBrowserModal = document.getElementById('closeDirectoryBrowserModal');
                this.currentPath = document.getElementById('currentPath');
                this.directoryBrowser = document.getElementById('directoryBrowser');
                this.selectDirectoryBtn = document.getElementById('selectDirectoryBtn');
                this.cancelDirectorySelection = document.getElementById('cancelDirectorySelection');
                
                // Debug: Check if directory browser elements were found
                console.log('Directory browser elements found:', {
                    closeDirectoryBrowserModal: !!this.closeDirectoryBrowserModal,
                    selectDirectoryBtn: !!this.selectDirectoryBtn,
                    cancelDirectorySelection: !!this.cancelDirectorySelection,
                    directoryBrowserModal: !!this.directoryBrowserModal
                });
                
                // Recipe preview elements
                this.recipePreviewPanel = document.getElementById('recipePreviewPanel');
                this.previewRecipeName = document.getElementById('previewRecipeName');
                this.previewRecipeDescription = document.getElementById('previewRecipeDescription');
                this.previewRecipeParameters = document.getElementById('previewRecipeParameters');
                this.confirmRecipeSelection = document.getElementById('confirmRecipeSelection');
                this.cancelRecipePreview = document.getElementById('cancelRecipePreview');
                
                // Recipe state
                this.selectedRecipe = null;
                this.availableRecipes = [];
                this.categories = [];
                
                // Provider/Model state
                this.availableProviders = [];
                this.currentProviderOverride = null;
                
                // Directory browser state
                this.currentWorkingDirectory = null;
                this.selectedDirectory = null;
                
                // Wizard state
                this.wizardCurrentStep = 1;
                this.wizardData = {
                    sessionName: '',
                    selectedRecipe: null,
                    workingDirectory: null
                };
                
                this.currentGooseStatus = null;
                this.setupTheme();
                this.loadProviders(); // Load provider/model options
                this.loadSettings(); // Load user settings
                this.setupEventListeners();
                this.setupSocketListeners();
                this.updateGooseControls(false);
                
                // Initialize working directory to current location
                this.initializeWorkingDirectory();
                
                // Load configuration and set input length
                this.loadConfig();
                
                // Auto-show session modal if no active session after initial load
                setTimeout(() => {
                    this.checkForAutoSessionModal();
                    // Also update active session status from MultiSessionManager
                    this.updateActiveSessionFromRunning();
                }, 1000);
            }
            
            async loadConfig() {
                try {
                    const response = await fetch('/api/config');
                    const config = await response.json();
                    
                    // Set the maxlength attribute on the textarea
                    this.messageInput.maxLength = config.inputLength;
                } catch (error) {
                    console.warn('Failed to load config, using default input length:', error);
                    // Fallback to default
                    this.messageInput.maxLength = 5000;
                }
            }
            
            async loadProviders() {
                try {
                    const response = await fetch('/api/goose-config/providers');
                    const data = await response.json();
                    this.availableProviders = data.providers || [];
                    this.populateProviderDropdowns();
                } catch (error) {
                    console.warn('Could not load providers:', error);
                    this.availableProviders = [];
                }
            }
            
            populateProviderDropdowns() {
                const dropdowns = [this.overrideProvider];
                
                dropdowns.forEach(dropdown => {
                    if (dropdown) {
                        dropdown.innerHTML = '<option value="">Use Recipe/Goose Default</option>';
                        
                        this.availableProviders.forEach(provider => {
                            const option = document.createElement('option');
                            option.value = provider.id;
                            option.textContent = provider.name;
                            if (!provider.configured) {
                                option.disabled = true;
                                option.textContent += ' (Not Configured)';
                            }
                            dropdown.appendChild(option);
                        });
                    }
                });
            }
            
            onOverrideProviderChange() {
                const selectedProvider = this.overrideProvider.value;
                
                if (!selectedProvider) {
                    this.overrideModelGroup.style.display = 'none';
                    this.overrideModel.innerHTML = '<option value="">Use Provider Default</option>';
                    return;
                }
                
                // Load models for selected provider
                const provider = this.availableProviders.find(p => p.id === selectedProvider);
                if (provider && provider.models && provider.models.length > 0) {
                    this.overrideModelGroup.style.display = 'block';
                    this.overrideModel.innerHTML = '<option value="">Use Provider Default</option>';
                    
                    provider.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model;
                        option.textContent = model;
                        this.overrideModel.appendChild(option);
                    });
                } else {
                    this.overrideModelGroup.style.display = 'none';
                }
            }
            
            setupTheme() {
                // Load saved theme or default to light
                const savedTheme = localStorage.getItem('goose-theme') || 'light';
                if (savedTheme === 'dark') {
                    document.body.classList.add('dark-theme');
                    this.updateFavicon(true);
                }
                
                // Setup theme toggles (desktop and mobile)
                const toggleTheme = () => {
                    document.body.classList.toggle('dark-theme');
                    const isDark = document.body.classList.contains('dark-theme');
                    localStorage.setItem('goose-theme', isDark ? 'dark' : 'light');
                    this.updateFavicon(isDark);
                };
                
                this.themeToggle.addEventListener('click', toggleTheme);
                this.mobileThemeToggle.addEventListener('click', toggleTheme);
            }
            
            updateFavicon(isDark) {
                const lightFavicon = document.getElementById('favicon-light');
                const darkFavicon = document.getElementById('favicon-dark');
                
                if (isDark) {
                    lightFavicon.disabled = true;
                    darkFavicon.disabled = false;
                } else {
                    lightFavicon.disabled = false;
                    darkFavicon.disabled = true;
                }
            }
            
            setupEventListeners() {
                // Helper function to safely add event listeners
                const safeAddEventListener = (element, elementName, event, handler) => {
                    if (element) {
                        element.addEventListener(event, handler);
                    } else {
                        console.warn(`${elementName} element not found - skipping event listener`);
                    }
                };
                
                safeAddEventListener(this.sendBtn, 'sendBtn', 'click', () => this.sendMessage());
                safeAddEventListener(this.interruptBtn, 'interruptBtn', 'click', () => this.interruptGoose());
                safeAddEventListener(this.clearBtn, 'clearBtn', 'click', () => this.clearConversation());
                safeAddEventListener(this.startSessionBtn, 'startSessionBtn', 'click', () => this.startGooseSession());
                safeAddEventListener(this.stopSessionBtn, 'stopSessionBtn', 'click', () => this.stopGooseSession());
                safeAddEventListener(this.listSessionsBtn, 'listSessionsBtn', 'click', () => this.listGooseSessions());
                safeAddEventListener(this.sendCommandBtn, 'sendCommandBtn', 'click', () => this.sendGooseCommand());
                
                // Modal event listeners
                safeAddEventListener(this.gooseStatus, 'gooseStatus', 'click', () => this.showSessionModal());
                safeAddEventListener(this.closeModal, 'closeModal', 'click', () => this.hideSessionModal());
                safeAddEventListener(this.createNewSessionBtn, 'createNewSessionBtn', 'click', () => this.startSessionWizard());
                
                // Wizard event listeners
                safeAddEventListener(this.closeWizardModal, 'closeWizardModal', 'click', () => this.hideSessionWizard());
                safeAddEventListener(this.wizardStep1Next, 'wizardStep1Next', 'click', () => this.wizardGoToStep(2));
                safeAddEventListener(this.wizardStep2Back, 'wizardStep2Back', 'click', () => this.wizardGoToStep(1));
                safeAddEventListener(this.wizardStep2Next, 'wizardStep2Next', 'click', () => this.wizardGoToProviderStep());
                safeAddEventListener(this.wizardStep2_5Back, 'wizardStep2_5Back', 'click', () => this.wizardGoToStep(2));
                safeAddEventListener(this.wizardStep2_5Next, 'wizardStep2_5Next', 'click', () => this.wizardGoToStep(3));
                safeAddEventListener(this.wizardStep3Back, 'wizardStep3Back', 'click', () => this.wizardGoToProviderStep());
                safeAddEventListener(this.wizardChooseRecipeBtn, 'wizardChooseRecipeBtn', 'click', () => this.wizardChooseRecipe());
                safeAddEventListener(this.wizardSkipRecipeBtn, 'wizardSkipRecipeBtn', 'click', () => this.wizardSkipRecipe());
                safeAddEventListener(this.wizardBrowseDirectoryBtn, 'wizardBrowseDirectoryBtn', 'click', () => this.wizardBrowseDirectory());
                safeAddEventListener(this.wizardUseCurrentDirBtn, 'wizardUseCurrentDirBtn', 'click', () => this.wizardUseCurrentDirectory());
                safeAddEventListener(this.wizardCreateSessionBtn, 'wizardCreateSessionBtn', 'click', () => this.wizardCreateSession());
                
                // Provider/Model override event listeners
                safeAddEventListener(this.enableProviderOverride, 'enableProviderOverride', 'change', () => this.toggleProviderOverride());
                safeAddEventListener(this.overrideProvider, 'overrideProvider', 'change', () => this.onOverrideProviderChange());
                
                // Recipe selector modal event listeners
                safeAddEventListener(this.selectRecipeBtn, 'selectRecipeBtn', 'click', () => this.showRecipeSelectorModal());
                safeAddEventListener(this.changeRecipeBtn, 'changeRecipeBtn', 'click', () => this.showRecipeSelectorModal());
                safeAddEventListener(this.closeRecipeSelectorModal, 'closeRecipeSelectorModal', 'click', () => this.hideRecipeSelectorModal());
                safeAddEventListener(this.clearRecipeSelection, 'clearRecipeSelection', 'click', () => this.clearSelectedRecipe());
                
                // Recipe preview event listeners
                safeAddEventListener(this.confirmRecipeSelection, 'confirmRecipeSelection', 'click', () => this.confirmRecipe());
                safeAddEventListener(this.cancelRecipePreview, 'cancelRecipePreview', 'click', () => this.hideRecipePreview());
                
                // Directory browser event listeners
                safeAddEventListener(this.browseDirectoryBtn, 'browseDirectoryBtn', 'click', () => this.showDirectoryBrowser());
                
                if (this.closeDirectoryBrowserModal) {
                    console.log('Adding click listener to closeDirectoryBrowserModal element:', this.closeDirectoryBrowserModal);
                    
                    this.closeDirectoryBrowserModal.addEventListener('click', (e) => {
                        console.log('üî• Close directory browser (X) clicked - Event object:', e);
                        console.log('üî• Event target:', e.target);
                        console.log('üî• Current target:', e.currentTarget);
                        e.preventDefault();
                        e.stopPropagation();
                        this.hideDirectoryBrowser();
                    });
                    
                    // Add mousedown listener
                    this.closeDirectoryBrowserModal.addEventListener('mousedown', (e) => {
                        console.log('üî• MOUSEDOWN on close (X) button');
                    });
                    
                    console.log('‚úÖ Event listeners added to closeDirectoryBrowserModal');
                } else {
                    console.error('‚ùå closeDirectoryBrowserModal element not found');
                }
                
                if (this.selectDirectoryBtn) {
                    console.log('Adding click listener to selectDirectoryBtn element:', this.selectDirectoryBtn);
                    
                    // Add multiple event listeners to debug
                    this.selectDirectoryBtn.addEventListener('click', (e) => {
                        console.log('üî• Select directory button clicked - Event object:', e);
                        console.log('üî• Event target:', e.target);
                        console.log('üî• Current target:', e.currentTarget);
                        console.log('üî• Button element:', this.selectDirectoryBtn);
                        console.log('üî• Selected directory:', this.selectedDirectory);
                        e.preventDefault();
                        e.stopPropagation();
                        this.confirmDirectorySelection();
                    });
                    
                    // Add mousedown listener too
                    this.selectDirectoryBtn.addEventListener('mousedown', (e) => {
                        console.log('üî• MOUSEDOWN on select directory button');
                    });
                    
                    // Add pointer events listener
                    this.selectDirectoryBtn.addEventListener('pointerdown', (e) => {
                        console.log('üî• POINTERDOWN on select directory button');
                    });
                    
                    console.log('‚úÖ Event listeners added to selectDirectoryBtn');
                } else {
                    console.error('‚ùå selectDirectoryBtn element not found');
                }
                
                if (this.cancelDirectorySelection) {
                    console.log('Adding click listener to cancelDirectorySelection element:', this.cancelDirectorySelection);
                    
                    this.cancelDirectorySelection.addEventListener('click', (e) => {
                        console.log('üî• Cancel directory button clicked - Event object:', e);
                        console.log('üî• Event target:', e.target);
                        console.log('üî• Current target:', e.currentTarget);
                        e.preventDefault();
                        e.stopPropagation();
                        this.hideDirectoryBrowser();
                    });
                    
                    // Add mousedown listener
                    this.cancelDirectorySelection.addEventListener('mousedown', (e) => {
                        console.log('üî• MOUSEDOWN on cancel directory button');
                    });
                    
                    console.log('‚úÖ Event listeners added to cancelDirectorySelection');
                } else {
                    console.error('‚ùå cancelDirectorySelection element not found');
                }
                
                // Recipe selection event listeners
                this.recipeTabs.forEach(tab => {
                    tab.addEventListener('click', () => this.switchRecipeTab(tab.dataset.tab));
                });
                
                this.recipeSearchInput.addEventListener('input', (e) => {
                    this.searchRecipes(e.target.value);
                });
                
                // Session search filter
                if (this.sessionSearchFilter) {
                    this.sessionSearchFilter.addEventListener('input', (e) => {
                        this.filterSessions(e.target.value);
                    });
                }
                
                // Settings modal event listeners
                this.settingsBtn.addEventListener('click', () => this.showSettingsModal());
                this.closeSettingsModal.addEventListener('click', () => this.hideSettingsModal());
                
                // Settings change listeners
                this.enableInterruptOnNewMessage.addEventListener('change', () => {
                    this.saveSettings();
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Ctrl+C to interrupt (like in CLI)
                    if (e.ctrlKey && e.key === 'c' && !e.target.matches('input, textarea')) {
                        e.preventDefault();
                        if (this.interruptBtn && this.interruptBtn.style.display !== 'none') {
                            this.interruptGoose();
                        }
                    }
                });
                
                // Close modals when clicking overlay
                this.sessionModal.addEventListener('click', (e) => {
                    if (e.target === this.sessionModal) {
                        this.hideSessionModal();
                    }
                });
                
                this.settingsModal.addEventListener('click', (e) => {
                    if (e.target === this.settingsModal) {
                        this.hideSettingsModal();
                    }
                });
                
                this.directoryBrowserModal.addEventListener('click', (e) => {
                    if (e.target === this.directoryBrowserModal) {
                        this.hideDirectoryBrowser();
                    }
                });
                
                this.sessionWizardModal.addEventListener('click', (e) => {
                    if (e.target === this.sessionWizardModal) {
                        this.hideSessionWizard();
                    }
                });
                
                this.messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });
                
                // Auto-resize textarea
                this.messageInput.addEventListener('input', () => {
                    this.resizeTextarea(this.messageInput);
                });
                
                this.commandInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.sendGooseCommand();
                    }
                });
                
                // Mobile menu event listeners
                this.mobileMenuToggle.addEventListener('click', () => this.showMobileMenu());
                this.mobileMenuClose.addEventListener('click', () => this.hideMobileMenu());
                this.mobileGooseStatus.addEventListener('click', () => {
                    this.hideMobileMenu();
                    this.showSessionModal();
                });
                this.mobileSettingsBtn.addEventListener('click', () => {
                    this.hideMobileMenu();
                    this.showSettingsModal();
                });
                
                // Close mobile menu when clicking outside
                this.mobileMenu.addEventListener('click', (e) => {
                    if (e.target === this.mobileMenu) {
                        this.hideMobileMenu();
                    }
                });
            }
            
            setupSocketListeners() {
                this.socket.on('connect', () => {
                    this.connectionBar.classList.remove('disconnected');
                    // Immediately check for active sessions when reconnecting
                    this.updateActiveSessionFromRunning();
                });
                
                this.socket.on('disconnect', () => {
                    this.connectionBar.classList.add('disconnected');
                });
                
                this.socket.on('conversationHistory', (messages) => {
                    // Clear all content and reset to streaming display
                    this.messagesDiv.innerHTML = '';
                    messages.forEach(message => this.appendMessage(message));
                    this.scrollToBottom();
                });
                
                this.socket.on('newMessage', (message) => {
                    this.appendMessage(message);
                    this.scrollToBottom();
                });
                
                this.socket.on('conversationCleared', () => {
                    this.messagesDiv.innerHTML = '';
                });
                
                this.socket.on('gooseStatusUpdate', (status) => {
                    this.updateGooseStatus(status);
                });
                
                this.socket.on('gooseError', (error) => {
                    this.appendText(`‚ùå Goose Error: ${error}\\n`, 'system-message');
                    this.scrollToBottom();
                });

                // Listen for interruption events
                this.socket.on('sessionInterrupted', (data) => {
                    console.log('Session interrupted:', data);
                    this.updateInterruptButton(true, false);
                });

                this.socket.on('sessionForceStopped', (data) => {
                    console.log('Session force stopped:', data);
                    this.updateInterruptButton(false, false);
                });

                this.socket.on('processingComplete', (data) => {
                    console.log('Processing complete:', data);
                    this.updateInterruptButton(true, false);
                });
                
                // Multi-session event listeners
                this.socket.on('sessionsUpdate', (update) => {
                    this.handleSessionsUpdate(update);
                });
                
                this.socket.on('sessionError', (error) => {
                    this.appendText(`‚ùå Session Error: ${error.error}\\n`, 'system-message');
                    this.scrollToBottom();
                });
            }
            
            handleSessionsUpdate(update) {
                switch (update.type) {
                    case 'sessionStarted':
                        this.appendText(`‚úÖ Session started: ${update.sessionName}\\n`, 'system-message');
                        this.loadRunningSessions();
                        // Update status to show the new active session
                        this.updateGooseStatus({
                            active: true,
                            sessionName: update.sessionName,
                            ready: true
                        });
                        break;
                    case 'sessionStopped':
                        this.appendText(`‚èπÔ∏è Session stopped: ${update.message}\\n`, 'system-message');
                        this.loadRunningSessions();
                        // If this was the active session, clear the status
                        if (this.sessionNameDisplay.textContent.includes(update.sessionName)) {
                            this.updateGooseStatus({
                                active: false,
                                sessionName: null,
                                ready: false
                            });
                        }
                        break;
                    case 'sessionSwitched':
                        this.appendText(`üîÑ Switched to session\\n`, 'system-message');
                        this.loadRunningSessions();
                        // Find the active session name from the conversation if available
                        this.updateActiveSessionFromRunning();
                        break;
                    case 'sessionResumed':
                        this.appendText(`‚ñ∂Ô∏è Session resumed: ${update.sessionName}\\n`, 'system-message');
                        this.loadRunningSessions();
                        // Update status to show the resumed session as active
                        this.updateGooseStatus({
                            active: true,
                            sessionName: update.sessionName,
                            ready: true
                        });
                        break;
                    case 'sessionReady':
                        this.loadRunningSessions();
                        break;
                    case 'sessionClosed':
                        this.appendText(`‚ùå Session closed unexpectedly\\n`, 'system-message');
                        this.loadRunningSessions();
                        break;
                }
                this.scrollToBottom();
            }
            
            async updateActiveSessionFromRunning() {
                try {
                    const response = await fetch('/api/sessions/running');
                    const runningSessions = await response.json();
                    
                    // Find the active session
                    const activeSession = runningSessions.find(session => session.isActive);
                    
                    if (activeSession) {
                        this.updateGooseStatus({
                            active: true,
                            sessionName: activeSession.sessionName,
                            ready: true,
                            workingDirectory: activeSession.workingDirectory
                        });
                    } else {
                        this.updateGooseStatus({
                            active: false,
                            sessionName: null,
                            ready: false,
                            workingDirectory: null
                        });
                    }
                } catch (error) {
                    console.error('Error updating active session status:', error);
                }
            }
            
            updateGooseStatus(status) {
                const statusEl = this.gooseStatus;
                const mobileStatusEl = this.mobileGooseStatus;
                
                if (status.active) {
                    const statusClass = 'goose-status status-active';
                    
                    // Just show the session name without "Active"
                    this.sessionNameDisplay.textContent = status.sessionName || 'Unknown Session';
                    
                    // Update working directory display
                    if (this.workingDirectoryDisplay && status.workingDirectory) {
                        this.workingDirectoryDisplay.textContent = status.workingDirectory;
                        this.workingDirectoryDisplay.title = status.workingDirectory; // Full path on hover
                        this.workingDirectoryInfo.style.display = 'flex';
                    } else if (this.workingDirectoryDisplay) {
                        this.workingDirectoryDisplay.textContent = '';
                        this.workingDirectoryInfo.style.display = 'none';
                    }
                    
                    // Update mobile working directory display
                    if (this.mobileWorkingDirectoryDisplay && status.workingDirectory) {
                        this.mobileWorkingDirectoryDisplay.textContent = status.workingDirectory;
                        this.mobileWorkingDirectoryDisplay.title = status.workingDirectory;
                        this.mobileWorkingDirectoryInfo.style.display = 'block';
                    } else if (this.mobileWorkingDirectoryDisplay) {
                        this.mobileWorkingDirectoryDisplay.textContent = '';
                        this.mobileWorkingDirectoryInfo.style.display = 'none';
                    }
                    
                    statusEl.className = statusClass;
                    
                    // Update mobile displays
                    if (this.mobileSessionNameDisplay) {
                        this.mobileSessionNameDisplay.textContent = status.sessionName || 'Unknown Session';
                    }
                    if (this.mobileWorkingDirectoryDisplay && status.workingDirectory) {
                        this.mobileWorkingDirectoryDisplay.textContent = status.workingDirectory;
                        this.mobileWorkingDirectoryDisplay.title = status.workingDirectory;
                    } else if (this.mobileWorkingDirectoryDisplay) {
                        this.mobileWorkingDirectoryDisplay.textContent = '';
                    }
                    mobileStatusEl.className = statusClass;
                } else {
                    const statusText = 'No Session Active';
                    const statusClass = 'goose-status status-inactive';
                    
                    // Update session name display
                    this.sessionNameDisplay.textContent = statusText;
                    
                    // Clear working directory display
                    if (this.workingDirectoryDisplay) {
                        this.workingDirectoryDisplay.textContent = '';
                        this.workingDirectoryInfo.style.display = 'none';
                    }
                    
                    // Clear mobile working directory display
                    if (this.mobileWorkingDirectoryDisplay) {
                        this.mobileWorkingDirectoryDisplay.textContent = '';
                        this.mobileWorkingDirectoryInfo.style.display = 'none';
                    }
                    
                    statusEl.className = statusClass;
                    
                    // Update mobile displays  
                    if (this.mobileSessionNameDisplay) {
                        this.mobileSessionNameDisplay.textContent = statusText;
                    }
                    if (this.mobileWorkingDirectoryDisplay) {
                        this.mobileWorkingDirectoryDisplay.textContent = '';
                    }
                    mobileStatusEl.className = statusClass;
                }
                
                // Load and update running sessions count
                this.loadRunningSessions();
                
                // Update provider/model display
                if (status.active && status.sessionName) {
                    this.updateProviderModelDisplay(status.sessionName);
                } else {
                    this.hideProviderModelDisplay();
                }
                
                this.updateGooseControls(status.active);
                this.currentGooseStatus = status;
            }
            
            async updateProviderModelDisplay(sessionName) {
                try {
                    // Find the active session ID by name
                    const runningResponse = await fetch('/api/sessions/running');
                    const runningSessions = await runningResponse.json();
                    
                    const activeSession = runningSessions.find(session => 
                        session.sessionName === sessionName && session.isActive
                    );
                    
                    if (activeSession && activeSession.sessionId) {
                        // Get detailed session info including provider/model
                        const infoResponse = await fetch(`/api/sessions/${activeSession.sessionId}/info`);
                        if (infoResponse.ok) {
                            const sessionInfo = await infoResponse.json();
                            
                            if (sessionInfo.provider || sessionInfo.model) {
                                const provider = sessionInfo.provider || 'Default';
                                const model = sessionInfo.model || 'Default';
                                
                                this.showProviderModelDisplay(provider, model);
                            } else {
                                this.hideProviderModelDisplay();
                            }
                        }
                    }
                } catch (error) {
                    console.warn('Could not load session provider/model info:', error);
                    this.hideProviderModelDisplay();
                }
            }
            
            showProviderModelDisplay(provider, model) {
                const displayText = `${provider} - ${model}`;
                
                // Update desktop display
                this.providerModelText.textContent = displayText;
                this.providerModelInfo.style.display = 'flex';
                
                // Update mobile display
                this.mobileProviderModelText.textContent = displayText;
                this.mobileProviderModelInfo.style.display = 'block';
            }
            
            hideProviderModelDisplay() {
                // Hide desktop display
                this.providerModelInfo.style.display = 'none';
                
                // Hide mobile display
                this.mobileProviderModelInfo.style.display = 'none';
            }
            
            async loadRunningSessions() {
                try {
                    const response = await fetch('/api/sessions/running');
                    const runningSessions = await response.json();
                    this.updateSessionCountBadge(runningSessions.length);
                } catch (error) {
                    console.error('Failed to load running sessions:', error);
                    this.updateSessionCountBadge(0);
                }
            }
            
            updateSessionCountBadge(sessionCount) {
                if (sessionCount > 0) {
                    this.sessionCountBadge.textContent = ` - (${sessionCount})`;
                    this.sessionCountBadge.style.display = 'inline';
                } else {
                    this.sessionCountBadge.style.display = 'none';
                }
            }
            
            checkForAutoSessionModal() {
                // Only show session modal automatically if no active session
                if (this.currentGooseStatus && !this.currentGooseStatus.active) {
                    console.log('Auto-showing session modal: no active session detected');
                    this.showSessionModal();
                } else if (!this.currentGooseStatus) {
                    // If we haven't received status yet, check server directly
                    this.checkServerStatusAndShowModal();
                }
            }
            
            async checkServerStatusAndShowModal() {
                try {
                    const response = await fetch('/api/goose/status');
                    const status = await response.json();
                    
                    if (!status.active) {
                        console.log('Auto-showing session modal: server reports no active session');
                        this.showSessionModal();
                    }
                } catch (error) {
                    console.error('Error checking server status:', error);
                    // If we can't check status, show modal anyway as a fallback
                    console.log('Auto-showing session modal: fallback due to status check error');
                    this.showSessionModal();
                }
            }
            
            updateGooseControls(active) {
                this.sendBtn.disabled = !active;
                this.sendCommandBtn.disabled = !active;
                this.stopSessionBtn.disabled = !active;
                this.startSessionBtn.disabled = active;
                
                // Interrupt button is only enabled when active and processing
                this.updateInterruptButton(active, false);
                
                if (!active) {
                    this.messageInput.placeholder = 'Start a Goose session first...';
                } else {
                    this.messageInput.placeholder = 'Type your message to Goose...';
                }
            }

            updateInterruptButton(sessionActive, isProcessing = false) {
                if (!this.interruptBtn) return;
                
                if (sessionActive && isProcessing) {
                    this.interruptBtn.style.display = 'flex';
                    this.interruptBtn.title = 'Stop current operation (Ctrl+C)';
                } else {
                    this.interruptBtn.style.display = 'none';
                    this.interruptBtn.title = 'Stop current operation (Ctrl+C)';
                }
            }
            
            appendMessage(message) {
                console.log('Appending message:', message.role, message.source, message.content.substring(0, 50));
                
                // Skip thinking and tool messages - they're included in the main stream
                if (message.type === 'thinking' || message.source === 'goose-thinking' || message.source === 'goose-tool') {
                    return;
                }
                
                const time = new Date(message.timestamp).toLocaleTimeString();
                
                if (message.role === 'user') {
                    // User input in blue with timestamp
                    this.appendText(`[${time}] You: ${message.content}\\n\\n`, 'user-input');
                } else if (message.role === 'system') {
                    // System messages in gray italic with timestamp
                    this.appendText(`[${time}] ${message.content}\\n\\n`, 'system-message');
                } else {
                    // Goose responses - format as markdown and flow naturally
                    console.log('Adding goose response as formatted text');
                    this.appendFormattedText(message.content + '\\n\\n');
                }
                
                // Always scroll to bottom after adding content
                this.scrollToBottom();
            }
            
            appendText(text, className = 'system-output') {
                const span = document.createElement('span');
                span.className = className;
                span.textContent = text;
                this.messagesDiv.appendChild(span);
            }
            
            appendFormattedText(text) {
                // Convert markdown to HTML for better formatting
                const formattedContent = this.formatMarkdown(text);
                
                const div = document.createElement('div');
                div.className = 'system-output';
                div.innerHTML = formattedContent;
                this.messagesDiv.appendChild(div);
            }
            
            formatMarkdown(text) {
                return text
                    // Headers
                    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                    .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                    // Bold
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    // Italic
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    // Code blocks
                    .replace(/```([\\s\\S]*?)```/g, '<pre><code>$1</code></pre>')
                    // Inline code
                    .replace(/`([^`]+)`/g, '<code>$1</code>')
                    // Links
                    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>')
                    // Line breaks
                    .replace(/\n/g, '<br>')
                    // Lists (basic support)
                    .replace(/^\s*[-*+] (.+)$/gim, '<li>$1</li>')
                    .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
            }
            
            resizeTextarea(textarea) {
                // Reset height to auto to get the scroll height
                textarea.style.height = 'auto';
                
                // Calculate the new height based on scroll height
                const lineHeight = parseFloat(getComputedStyle(textarea).lineHeight);
                const padding = parseFloat(getComputedStyle(textarea).paddingTop) + parseFloat(getComputedStyle(textarea).paddingBottom);
                const maxLines = window.innerWidth <= 768 ? 3 : 5; // 3 lines on mobile, 5 on desktop
                const maxHeight = (lineHeight * maxLines) + padding;
                
                const newHeight = Math.min(textarea.scrollHeight, maxHeight);
                textarea.style.height = newHeight + 'px';
            }
            
            async sendMessage() {
                const content = this.messageInput.value.trim();
                if (!content) return;
                
                // Debug logging for frontend
                console.log('=== FRONTEND SENDING MESSAGE ===');
                console.log('Content length:', content.length);
                console.log('Contains newlines:', content.includes('\n'));
                console.log('Newline count:', (content.match(/\n/g) || []).length);
                console.log('Raw content:', JSON.stringify(content));
                console.log('================================');
                
                this.messageInput.value = '';
                this.resizeTextarea(this.messageInput);
                this.sendBtn.disabled = true;
                this.loading.style.display = 'block';
                
                // Enable interrupt button while processing
                this.updateInterruptButton(true, true);
                
                try {
                    const response = await fetch('/api/message', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ 
                            content,
                            settings: this.settings 
                        })
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to send message');
                    }
                    
                } catch (error) {
                    console.error('Error sending message:', error);
                    this.appendText(`‚ùå Failed to send message: ${error.message}\\n`, 'system-message');
                    this.scrollToBottom();
                } finally {
                    this.sendBtn.disabled = false;
                    this.loading.style.display = 'none';
                    
                    // Disable interrupt button when done processing
                    this.updateInterruptButton(true, false);
                }
            }
            
            async startGooseSession() {
                const sessionName = this.sessionNameInput.value.trim();
                
                try {
                    const response = await fetch('/api/goose/start', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ 
                            sessionName: sessionName || undefined,
                            builtins: ['developer']
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.sessionNameInput.value = '';
                        this.appendText(`‚úÖ Started Goose session: ${result.sessionName}\\n`, 'system-message');
                        this.scrollToBottom();
                    } else {
                        throw new Error(result.error);
                    }
                    
                } catch (error) {
                    console.error('Error starting session:', error);
                    this.appendText(`‚ùå Failed to start Goose session: ${error.message}\\n`, 'system-message');
                    this.scrollToBottom();
                }
            }
            
            async interruptGoose() {
                try {
                    console.log('üõë Interrupting Goose...');
                    
                    const response = await fetch('/api/goose/interrupt', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        this.appendText('üõë Interrupted current operation\\n', 'system-message');
                        this.scrollToBottom();
                        
                        // Update interrupt button state
                        this.updateInterruptButton(true, false);
                    } else {
                        const error = await response.json();
                        this.appendText(`‚ùå Failed to interrupt: ${error.error}\\n`, 'system-message');
                        this.scrollToBottom();
                    }
                    
                } catch (error) {
                    console.error('Error interrupting Goose:', error);
                    this.appendText(`‚ùå Failed to interrupt Goose: ${error.message}\\n`, 'system-message');
                    this.scrollToBottom();
                }
            }

            async stopGooseSession() {
                try {
                    const response = await fetch('/api/goose/stop', {
                        method: 'POST'
                    });
                    
                    if (response.ok) {
                        this.appendText('‚èπ Stopped Goose session\\n', 'system-message');
                        this.scrollToBottom();
                    }
                    
                } catch (error) {
                    console.error('Error stopping session:', error);
                    this.appendText('‚ùå Failed to stop Goose session\\n', 'system-message');
                    this.scrollToBottom();
                }
            }
            
            async listGooseSessions() {
                try {
                    const response = await fetch('/api/goose/sessions');
                    const sessions = await response.json();
                    
                    if (sessions.length === 0) {
                        this.appendText('üìã No Goose sessions found\\n', 'system-message');
                        this.scrollToBottom();
                    } else {
                        const sessionList = sessions.map((s, i) => 
                            `${i + 1}. ${s.name || s.id || 'Unnamed'}`
                        ).join('\\n');
                        
                        this.appendText(`üìã Available Goose sessions:\\n${sessionList}\\n`, 'system-message');
                        this.scrollToBottom();
                    }
                    
                } catch (error) {
                    console.error('Error listing sessions:', error);
                    this.appendText('‚ùå Failed to list Goose sessions\\n', 'system-message');
                    this.scrollToBottom();
                }
            }
            
            async sendGooseCommand() {
                const command = this.commandInput.value.trim();
                if (!command) return;
                
                this.commandInput.value = '';
                
                try {
                    const response = await fetch('/api/goose/command', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ command })
                    });
                    
                    if (response.ok) {
                        this.appendText(`üì§ Sent command: ${command}\\n`, 'system-message');
                        this.scrollToBottom();
                    } else {
                        const error = await response.json();
                        throw new Error(error.error);
                    }
                    
                } catch (error) {
                    console.error('Error sending command:', error);
                    this.appendText(`‚ùå Failed to send command: ${error.message}\\n`, 'system-message');
                    this.scrollToBottom();
                }
            }
            
            clearConversation() {
                if (confirm('Are you sure you want to clear the conversation?')) {
                    fetch('/api/conversation', { method: 'DELETE' })
                        .catch(error => console.error('Error clearing conversation:', error));
                }
            }
            
            scrollToBottom() {
                // Use requestAnimationFrame to ensure DOM updates are complete
                requestAnimationFrame(() => {
                    this.messagesDiv.scrollTop = this.messagesDiv.scrollHeight;
                });
            }
            
            async showSessionModal() {
                try {
                    // Fetch both running and available sessions
                    const [runningResponse, availableResponse] = await Promise.all([
                        fetch('/api/sessions/running'),
                        fetch('/api/sessions/available')
                    ]);
                    
                    const runningSessions = await runningResponse.json();
                    const availableSessions = await availableResponse.json();
                    
                    
                    this.populateEnhancedSessionList(runningSessions, availableSessions);
                    this.sessionModal.classList.add('show');
                } catch (error) {
                    console.error('Error fetching sessions:', error);
                    this.appendText(`‚ùå Failed to fetch sessions: ${error.message}\\n`, 'system-message');
                }
            }
            
            hideSessionModal() {
                this.sessionModal.classList.remove('show');
                this.newSessionName.value = '';
                // Don't clear recipe selection here - let individual methods handle it
            }

            // Recipe Selector Modal Methods
            async showRecipeSelectorModal() {
                // Load popular recipes on first show
                if (!this.popularRecipeGrid.innerHTML.trim()) {
                    await this.loadPopularRecipes();
                }
                
                this.recipeSelectorModal.classList.add('show');
            }

            hideRecipeSelectorModal() {
                this.recipeSelectorModal.classList.remove('show');
                this.hideRecipePreview();
            }

            showRecipePreview(recipe) {
                this.previewRecipeName.textContent = recipe.name;
                this.previewRecipeDescription.textContent = recipe.description;
                
                // Show parameters if any
                if (recipe.parameters && recipe.parameters.length > 0) {
                    this.previewRecipeParameters.innerHTML = `
                        <div style="margin-top: 1rem;">
                            <strong>Parameters:</strong>
                            <ul style="margin-left: 1rem; margin-top: 0.5rem;">
                                ${recipe.parameters.map(param => `
                                    <li>${param.label || param.name}${param.required ? ' *' : ''}</li>
                                `).join('')}
                            </ul>
                        </div>
                    `;
                } else {
                    this.previewRecipeParameters.innerHTML = '';
                }
                
                this.recipePreviewPanel.style.display = 'block';
                this.currentPreviewRecipe = recipe;
            }

            hideRecipePreview() {
                this.recipePreviewPanel.style.display = 'none';
                this.currentPreviewRecipe = null;
            }

            confirmRecipe() {
                if (this.currentPreviewRecipe) {
                    this.selectedRecipe = this.currentPreviewRecipe;
                    this.updateSelectedRecipeDisplay();
                    this.hideRecipeSelectorModal();
                }
            }

            updateSelectedRecipeDisplay() {
                if (this.selectedRecipe) {
                    this.selectedRecipeName.textContent = this.selectedRecipe.name;
                    this.selectedRecipeDescription.textContent = this.selectedRecipe.description;
                    
                    // Add parameter inputs if the recipe has parameters
                    let parametersHtml = '';
                    if (this.selectedRecipe.parameters && this.selectedRecipe.parameters.length > 0) {
                        parametersHtml = `
                            <div class="recipe-parameters" style="margin-top: 1rem;">
                                <strong>Parameters:</strong>
                                ${this.selectedRecipe.parameters.map(param => `
                                    <div class="parameter-input" style="margin-top: 0.5rem;">
                                        <label class="parameter-label" for="session-param-${param.name}" style="display: block; font-size: 0.8rem; margin-bottom: 0.25rem;">
                                            ${param.label || param.name}${param.required ? ' *' : ''}
                                        </label>
                                        ${this.renderParameterInputForSession(param)}
                                    </div>
                                `).join('')}
                            </div>
                        `;
                    }
                    
                    // Update the description element to include parameters
                    this.selectedRecipeDescription.innerHTML = this.selectedRecipe.description + parametersHtml;
                    this.selectedRecipeDisplay.style.display = 'block';
                } else {
                    this.selectedRecipeDisplay.style.display = 'none';
                }
            }
            
            showSettingsModal() {
                this.settingsModal.classList.add('show');
            }
            
            hideSettingsModal() {
                this.settingsModal.classList.remove('show');
            }

            loadSettings() {
                try {
                    const settings = JSON.parse(localStorage.getItem('wingman-settings')) || {};
                    
                    // Default settings
                    const defaults = {
                        enableInterruptOnNewMessage: true
                    };
                    
                    // Merge with defaults
                    this.settings = { ...defaults, ...settings };
                    
                    // Apply settings to UI
                    if (this.enableInterruptOnNewMessage) {
                        this.enableInterruptOnNewMessage.checked = this.settings.enableInterruptOnNewMessage;
                    }
                } catch (error) {
                    console.error('Error loading settings:', error);
                    this.settings = { enableInterruptOnNewMessage: true };
                }
            }

            saveSettings() {
                try {
                    this.settings = {
                        enableInterruptOnNewMessage: this.enableInterruptOnNewMessage?.checked ?? true
                    };
                    
                    localStorage.setItem('wingman-settings', JSON.stringify(this.settings));
                    console.log('Settings saved:', this.settings);
                } catch (error) {
                    console.error('Error saving settings:', error);
                }
            }
            
            showMobileMenu() {
                this.mobileMenu.classList.add('show');
                // Prevent body scrolling when menu is open
                document.body.style.overflow = 'hidden';
            }
            
            hideMobileMenu() {
                this.mobileMenu.classList.remove('show');
                // Restore body scrolling
                document.body.style.overflow = '';
            }
            
            populateSessionList(sessions) {
                this.sessionList.innerHTML = '';
                
                if (sessions.length === 0) {
                    this.sessionList.innerHTML = '<div class="empty-sessions">No active sessions found</div>';
                    return;
                }
                
                sessions.forEach(session => {
                    const sessionItem = document.createElement('div');
                    sessionItem.className = 'session-item';
                    
                    const sessionName = session.id || session.name || 'Unnamed Session';
                    const sessionDate = session.modified ? new Date(session.modified).toLocaleString() : 'Unknown date';
                    
                    sessionItem.innerHTML = `
                        <div class="session-info">
                            <div class="session-name">${sessionName}</div>
                            <div class="session-date">${sessionDate}</div>
                        </div>
                        <div class="session-actions">
                            <button class="btn-small btn-resume" data-session="${sessionName}">Resume</button>
                            <button class="btn-small btn-delete" data-session="${sessionName}">Delete</button>
                        </div>
                    `;
                    
                    // Add click handler for resume button
                    const resumeBtn = sessionItem.querySelector('.btn-resume');
                    resumeBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.resumeSession(sessionName);
                    });
                    
                    // Add click handler for delete button
                    const deleteBtn = sessionItem.querySelector('.btn-delete');
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.deleteSession(sessionName);
                    });
                    
                    // Add click handler for the entire item
                    sessionItem.addEventListener('click', () => {
                        this.resumeSession(sessionName);
                    });
                    
                    this.sessionList.appendChild(sessionItem);
                });
            }
            
            populateEnhancedSessionList(runningSessions, availableSessions) {
                // Store data for filtering
                this.allRunningSessions = runningSessions || [];
                this.allAvailableSessions = availableSessions || [];
                
                // Filter out running sessions from available sessions to avoid duplication
                const runningSessionNames = new Set(this.allRunningSessions.map(s => s.sessionName));
                this.filteredAvailableSessions = this.allAvailableSessions.filter(session => {
                    const sessionName = session.id || session.name || 'Unnamed Session';
                    return !runningSessionNames.has(sessionName);
                });
                
                // Clear search filter when repopulating
                if (this.sessionSearchFilter) {
                    this.sessionSearchFilter.value = '';
                }
                
                this.renderSessionList(this.allRunningSessions, this.filteredAvailableSessions);
            }
            
            renderSessionList(runningSessions, availableSessions) {
                this.sessionList.innerHTML = '';
                
                let content = '';
                
                // Add running sessions section
                if (runningSessions.length > 0) {
                    content += `
                        <div class="modal-section">
                            <h4>Running Sessions</h4>
                            ${runningSessions.map(session => `
                                <div class="session-item ${session.isActive ? 'active-session' : ''}" data-session-id="${session.sessionId}">
                                    <div class="session-info">
                                        <div class="session-name">${session.sessionName}</div>
                                        <div class="session-meta">
                                            <span class="session-status">(running)</span>
                                            <span class="session-timestamp">${new Date(session.createdAt).toLocaleString()}</span>
                                            <div class="session-directory">${session.workingDirectory || ''}</div>
                                        </div>
                                    </div>
                                    <div class="session-actions">
                                        ${!session.isActive ? `
                                            <button class="btn btn-primary btn-switch" data-session-id="${session.sessionId}">
                                                Switch To
                                            </button>
                                        ` : ''}
                                        <button class="btn btn-danger btn-stop" data-session-id="${session.sessionId}">
                                            Stop
                                        </button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }
                
                // Add available sessions section
                if (availableSessions.length > 0) {
                    content += `
                        <div class="modal-section">
                            <h4>Available Sessions</h4>
                            ${availableSessions.map(session => {
                                const sessionName = session.id || session.name || 'Unnamed Session';
                                const sessionDate = session.modified ? new Date(session.modified).toLocaleString() : 'Unknown date';
                                return `
                                    <div class="session-item available-session">
                                        <div class="session-info">
                                            <div class="session-name">${sessionName}</div>
                                            <div class="session-date">${sessionDate}</div>
                                        </div>
                                        <div class="session-actions">
                                            <button class="btn btn-primary btn-resume" data-session="${sessionName}">Resume</button>
                                            <button class="btn btn-danger btn-delete" data-session="${sessionName}">Delete</button>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    `;
                }
                
                if (runningSessions.length === 0 && availableSessions.length === 0) {
                    content = '<div class="empty-sessions">No sessions found</div>';
                }
                
                this.sessionList.innerHTML = content;
                
                // Add styles for enhanced session modal
                this.addSessionModalStyles();
                
                // Add event listeners for session actions
                this.addSessionActionListeners();
            }
            
            filterSessions(searchTerm) {
                if (!searchTerm) {
                    // Show all sessions if no search term
                    this.renderSessionList(this.allRunningSessions, this.filteredAvailableSessions);
                    return;
                }
                
                const filterText = searchTerm.toLowerCase();
                
                // Filter running sessions
                const filteredRunning = this.allRunningSessions.filter(session => 
                    session.sessionName.toLowerCase().includes(filterText)
                );
                
                // Filter available sessions
                const filteredAvailable = this.filteredAvailableSessions.filter(session => {
                    const sessionName = session.id || session.name || 'Unnamed Session';
                    return sessionName.toLowerCase().includes(filterText);
                });
                
                this.renderSessionList(filteredRunning, filteredAvailable);
                
                // Add event listeners for session actions
                this.addSessionActionListeners();
            }
            
            addSessionModalStyles() {
                if (document.getElementById('session-modal-styles')) return;
                
                const style = document.createElement('style');
                style.id = 'session-modal-styles';
                style.textContent = `
                    .session-item.active-session {
                        border: 2px solid var(--accent-primary) !important;
                        border-radius: 6px;
                        background-color: var(--accent-light);
                    }
                    
                    .session-item {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        padding: 12px;
                        border: 1px solid var(--border-primary);
                        border-radius: 4px;
                        margin: 8px 0;
                        background: var(--bg-primary);
                        cursor: pointer;
                        transition: all 0.2s ease;
                    }
                    
                    .session-item:hover:not(.active-session) {
                        background: var(--bg-secondary);
                        border-color: var(--accent-primary);
                        transform: translateY(-1px);
                        box-shadow: var(--shadow-sm);
                    }
                    
                    .session-item.active-session {
                        cursor: default;
                    }
                    
                    .session-info {
                        flex-grow: 1;
                    }
                    
                    .session-name {
                        font-weight: bold;
                        margin-bottom: 4px;
                        color: var(--text-primary);
                    }
                    
                    .session-meta {
                        font-size: 0.9em;
                        color: var(--text-muted);
                    }
                    
                    .session-status {
                        color: var(--accent-primary);
                        font-weight: bold;
                        margin-right: 12px;
                    }
                    
                    .session-directory {
                        font-style: italic;
                        margin-top: 2px;
                    }
                    
                    .session-actions {
                        display: flex;
                        gap: 8px;
                        flex-shrink: 0;
                    }
                    
                    .session-actions .btn {
                        padding: 8px 16px;
                        min-height: 36px;
                        font-size: 0.875rem;
                        border-radius: 4px;
                        border: none;
                        cursor: pointer;
                        font-weight: 500;
                        transition: all 0.2s ease;
                    }
                    
                    .session-actions .btn-primary {
                        background: var(--accent-primary);
                        color: white;
                    }
                    
                    .session-actions .btn-primary:hover {
                        background: var(--accent-secondary);
                        transform: translateY(-1px);
                    }
                    
                    .session-actions .btn-danger {
                        background: #dc2626;
                        color: white;
                    }
                    
                    .session-actions .btn-danger:hover {
                        background: #b91c1c;
                        transform: translateY(-1px);
                    }
                    
                    .modal-section {
                        margin-bottom: 20px;
                    }
                    
                    .modal-section h4 {
                        color: var(--text-primary);
                        margin-bottom: 12px;
                        padding-bottom: 4px;
                        border-bottom: 1px solid var(--border-primary);
                    }
                `;
                document.head.appendChild(style);
            }
            
            addSessionActionListeners() {
                // Click to switch/resume session functionality
                document.querySelectorAll('.session-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        // Don't trigger if clicking on a button
                        if (e.target.tagName === 'BUTTON') {
                            return;
                        }
                        
                        const sessionId = item.dataset.sessionId;
                        const sessionName = item.querySelector('.session-name').textContent;
                        
                        if (item.classList.contains('available-session')) {
                            // Resume available session
                            this.resumeSession(sessionName);
                        } else if (sessionId && !item.classList.contains('active-session')) {
                            // Switch to running session (if not already active)
                            this.switchToSession(sessionId);
                        }
                        // Do nothing if clicking on already active session
                    });
                });
                
                // Switch session functionality
                document.querySelectorAll('.btn-switch').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        await this.switchToSession(btn.dataset.sessionId);
                    });
                });
                
                // Stop session functionality with subprocess termination
                document.querySelectorAll('.btn-stop').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        
                        const sessionItem = btn.closest('.session-item');
                        const sessionName = sessionItem.querySelector('.session-name').textContent;
                        
                        if (confirm(`Stop session "${sessionName}"? This will terminate the subprocess. You can resume the session later using the usual process.`)) {
                            await this.stopSession(btn.dataset.sessionId);
                        }
                    });
                });
                
                // Resume session functionality (for available sessions)
                document.querySelectorAll('.btn-resume').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.resumeSession(btn.dataset.session);
                    });
                });
                
                // Delete session functionality (for available sessions)
                document.querySelectorAll('.btn-delete').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.deleteSession(btn.dataset.session);
                    });
                });
            }
            
            async switchToSession(sessionId) {
                try {
                    // Get session name before switching for better feedback
                    const sessionItem = document.querySelector(`[data-session-id="${sessionId}"]`);
                    const sessionName = sessionItem ? sessionItem.querySelector('.session-name').textContent : 'Unknown';
                    
                    const response = await fetch(`/api/sessions/switch/${sessionId}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        
                        // Hide modal and update UI
                        this.hideSessionModal();
                        this.appendText(`‚úÖ Switched to session: ${sessionName}\\n`, 'system-message');
                        
                        // Update status immediately
                        this.updateGooseStatus({
                            active: true,
                            sessionName: sessionName,
                            ready: true
                        });
                        
                        // Refresh session modal data
                        this.loadRunningSessions();
                        
                    } else {
                        throw new Error('Failed to switch session');
                    }
                } catch (error) {
                    console.error('Error switching session:', error);
                    this.appendText(`‚ùå Error switching session: ${error.message}\\n`, 'system-message');
                }
            }
            
            async stopSession(sessionId) {
                try {
                    // Get session name and check if it's active before stopping
                    const sessionItem = document.querySelector(`[data-session-id="${sessionId}"]`);
                    const sessionName = sessionItem ? sessionItem.querySelector('.session-name').textContent : 'Unknown';
                    const isActiveSession = sessionItem ? sessionItem.classList.contains('active-session') : false;
                    
                    const response = await fetch(`/api/sessions/stop/${sessionId}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        
                        // Update UI
                        this.appendText(`‚úÖ Session stopped: ${sessionName}. Can be resumed later.\\n`, 'system-message');
                        
                        // If we stopped the active session, update status
                        if (isActiveSession) {
                            this.updateGooseStatus({
                                active: false,
                                sessionName: null,
                                ready: false
                            });
                        }
                        
                        // Refresh the session modal
                        this.showSessionModal();
                        
                    } else {
                        throw new Error('Failed to stop session');
                    }
                } catch (error) {
                    console.error('Error stopping session:', error);
                    this.appendText(`‚ùå Error stopping session: ${error.message}\\n`, 'system-message');
                }
            }
            
            async resumeSession(sessionName) {
                this.hideSessionModal();
                this.clearSelectedRecipe(); // Clear recipe selection for resumed sessions
                
                try {
                    const response = await fetch('/api/goose/resume', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ sessionName })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.appendText(`‚úÖ Resumed session: ${sessionName}\\n`, 'system-message');
                        this.scrollToBottom();
                    } else {
                        throw new Error(result.error);
                    }
                    
                } catch (error) {
                    console.error('Error resuming session:', error);
                    this.appendText(`‚ùå Failed to resume session: ${error.message}\\n`, 'system-message');
                    this.scrollToBottom();
                }
            }
            
            async startSessionFromModal() {
                const sessionName = this.newSessionName.value.trim();
                
                if (this.selectedRecipe) {
                    // Start with recipe
                    await this.startSessionWithRecipe(sessionName);
                } else {
                    // Start regular session
                    await this.startRegularSession(sessionName);
                }
            }

            async startRegularSession(sessionName) {
                this.hideSessionModal();
                this.clearSelectedRecipe();
                
                try {
                    const response = await fetch('/api/goose/start', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ 
                            sessionName: sessionName || undefined,
                            builtins: ['developer'],
                            workingDirectory: this.currentWorkingDirectory
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.appendText(`‚úÖ Started new session: ${result.sessionName}\n`, 'system-message');
                        this.scrollToBottom();
                    } else {
                        throw new Error(result.error);
                    }
                    
                } catch (error) {
                    console.error('Error starting new session:', error);
                    this.appendText(`‚ùå Failed to start new session: ${error.message}\n`, 'system-message');
                    this.scrollToBottom();
                }
            }
            
            // Recipe Methods
            async loadPopularRecipes() {
                try {
                    const response = await fetch('/api/recipes/popular?limit=6');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    const recipes = await response.json();
                    this.renderRecipeGrid(recipes, this.popularRecipeGrid);
                } catch (error) {
                    console.error('Error loading popular recipes:', error);
                    this.popularRecipeGrid.innerHTML = '<p class="text-muted">Failed to load popular recipes</p>';
                }
            }
            
            async loadCategories() {
                try {
                    const response = await fetch('/api/recipes/categories');
                    this.categories = await response.json();
                    this.renderCategories();
                } catch (error) {
                    console.error('Error loading categories:', error);
                }
            }
            
            renderCategories() {
                this.categoryList.innerHTML = this.categories.map(category => `
                    <button class="category-button" data-category="${category.id}">
                        ${category.icon} ${category.name}
                    </button>
                `).join('');
                
                // Add event listeners
                this.categoryList.querySelectorAll('.category-button').forEach(btn => {
                    btn.addEventListener('click', () => this.loadRecipesByCategory(btn.dataset.category));
                });
            }
            
            async loadRecipesByCategory(categoryId) {
                try {
                    // Update active category button
                    this.categoryList.querySelectorAll('.category-button').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.category === categoryId);
                    });
                    
                    const response = await fetch(`/api/recipes?category=${categoryId}`);
                    const recipes = await response.json();
                    this.renderRecipeGrid(recipes, this.categoryRecipeGrid);
                } catch (error) {
                    console.error('Error loading recipes by category:', error);
                }
            }
            
            async searchRecipes(query) {
                if (!query.trim()) {
                    this.searchRecipeGrid.innerHTML = '<p class="text-muted">Enter a search term to find recipes</p>';
                    return;
                }
                
                try {
                    const response = await fetch('/api/recipes/search', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ query })
                    });
                    const recipes = await response.json();
                    this.renderRecipeGrid(recipes, this.searchRecipeGrid);
                } catch (error) {
                    console.error('Error searching recipes:', error);
                }
            }
            
            renderRecipeGrid(recipes, container) {
                if (!recipes.length) {
                    container.innerHTML = '<p class="text-muted">No recipes found</p>';
                    return;
                }
                
                container.innerHTML = recipes.map(recipe => `
                    <div class="recipe-card" data-recipe-id="${recipe.id}">
                        <div class="recipe-card-title">${recipe.name}</div>
                        <div class="recipe-card-description">${recipe.description}</div>
                        <div class="recipe-card-tags">
                            ${recipe.tags.slice(0, 3).map(tag => `<span class="recipe-tag">${tag}</span>`).join('')}
                        </div>
                    </div>
                `).join('');
                
                // Add click event listeners
                container.querySelectorAll('.recipe-card').forEach(card => {
                    card.addEventListener('click', () => this.previewRecipe(card.dataset.recipeId));
                });
            }
            
            async previewRecipe(recipeId) {
                try {
                    const response = await fetch(`/api/recipes/${recipeId}`);
                    const recipe = await response.json();
                    
                    // Highlight selected card
                    document.querySelectorAll('.recipe-card').forEach(card => {
                        card.classList.toggle('selected', card.dataset.recipeId === recipeId);
                    });
                    
                    this.showRecipePreview(recipe);
                } catch (error) {
                    console.error('Error loading recipe:', error);
                }
            }
            
            renderRecipeParameters() {
                if (!this.selectedRecipe.parameters || this.selectedRecipe.parameters.length === 0) {
                    this.recipeParameters.innerHTML = '';
                    return;
                }
                
                this.recipeParameters.innerHTML = this.selectedRecipe.parameters.map(param => `
                    <div class="parameter-input">
                        <label class="parameter-label" for="param-${param.name}">
                            ${param.label || param.name}${param.required ? ' *' : ''}
                        </label>
                        ${param.description ? `<div class="parameter-description">${param.description}</div>` : ''}
                        ${this.renderParameterInput(param)}
                    </div>
                `).join('');
            }
            
            renderParameterInput(param) {
                const baseAttrs = `id="param-${param.name}" name="${param.name}" class="form-input"`;
                
                switch (param.type) {
                    case 'select':
                        return `<select ${baseAttrs}>
                            ${param.options.map(option => 
                                `<option value="${option}" ${option === param.default ? 'selected' : ''}>${option}</option>`
                            ).join('')}
                        </select>`;
                    
                    case 'boolean':
                        return `<select ${baseAttrs}>
                            <option value="true" ${param.default === true ? 'selected' : ''}>Yes</option>
                            <option value="false" ${param.default === false ? 'selected' : ''}>No</option>
                        </select>`;
                    
                    case 'number':
                        return `<input type="number" ${baseAttrs} 
                            value="${param.default || ''}" 
                            ${param.validation?.min ? `min="${param.validation.min}"` : ''}
                            ${param.validation?.max ? `max="${param.validation.max}"` : ''}>`;
                    
                    default: // string
                        return `<input type="text" ${baseAttrs} 
                            value="${param.default || ''}" 
                            placeholder="${param.description || ''}">`;
                }
            }
            
            renderParameterInputForSession(param) {
                const baseAttrs = `id="session-param-${param.name}" name="${param.name}" class="form-input" style="font-size: 0.8rem; padding: 0.5rem;"`;
                
                switch (param.type) {
                    case 'select':
                        return `<select ${baseAttrs}>
                            ${param.options.map(option => 
                                `<option value="${option}" ${option === param.default ? 'selected' : ''}>${option}</option>`
                            ).join('')}
                        </select>`;
                    
                    case 'boolean':
                        return `<select ${baseAttrs}>
                            <option value="true" ${param.default === true ? 'selected' : ''}>Yes</option>
                            <option value="false" ${param.default === false ? 'selected' : ''}>No</option>
                        </select>`;
                    
                    case 'number':
                        return `<input type="number" ${baseAttrs} 
                            value="${param.default || ''}" 
                            ${param.validation?.min ? `min="${param.validation.min}"` : ''}
                            ${param.validation?.max ? `max="${param.validation.max}"` : ''}>`;
                    
                    default: // string
                        return `<input type="text" ${baseAttrs} 
                            value="${param.default || ''}" 
                            placeholder="${param.description || ''}">`;
                }
            }
            
            clearSelectedRecipe() {
                this.selectedRecipe = null;
                if (this.selectedRecipeDisplay) {
                    this.selectedRecipeDisplay.style.display = 'none';
                }
                
                // Clear selected state from all cards
                document.querySelectorAll('.recipe-card').forEach(card => {
                    card.classList.remove('selected');
                });
            }
            
            switchRecipeTab(tabName) {
                // Update tab buttons
                this.recipeTabs.forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.tab === tabName);
                });
                
                // Update tab content
                this.recipeTabContents.forEach(content => {
                    content.classList.toggle('active', content.id === `${tabName}-recipes`);
                });
                
                // Load content if needed
                if (tabName === 'popular' && !this.popularRecipeGrid.innerHTML.trim()) {
                    this.loadPopularRecipes();
                } else if (tabName === 'categories' && !this.categoryList.innerHTML.trim()) {
                    this.loadCategories();
                }
            }
            
            getParameterValues() {
                if (!this.selectedRecipe?.parameters) return {};
                
                const values = {};
                this.selectedRecipe.parameters.forEach(param => {
                    // Try session parameter inputs first, then fall back to modal parameter inputs
                    let input = document.getElementById(`session-param-${param.name}`) || 
                               document.getElementById(`param-${param.name}`);
                    
                    if (input) {
                        let value = input.value;
                        
                        // Type conversion
                        if (param.type === 'number') {
                            value = value ? Number(value) : undefined;
                        } else if (param.type === 'boolean') {
                            value = value === 'true';
                        }
                        
                        values[param.name] = value;
                    }
                });
                
                return values;
            }
            
            async startSessionWithRecipe(sessionName) {
                if (!this.selectedRecipe) {
                    console.error('No recipe selected');
                    this.appendText(`‚ùå No recipe selected. Please select a recipe first.\n`, 'system-message');
                    return;
                }
                
                // Collect parameter values if the recipe has parameters
                const parameters = this.getParameterValues();
                
                // Store recipe info before hiding modal
                const recipeId = this.selectedRecipe.id;
                const recipeName = this.selectedRecipe.name;
                
                this.hideSessionModal();
                
                try {
                    // Collect provider override if enabled
                    let providerOverride = null;
                    if (this.currentProviderOverride) {
                        providerOverride = {
                            provider: this.currentProviderOverride.provider,
                            model: this.currentProviderOverride.model
                        };
                    }

                    const response = await fetch('/api/goose/start-with-recipe', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            recipeId: recipeId,
                            sessionName: sessionName || undefined,
                            parameters,
                            workingDirectory: this.currentWorkingDirectory,
                            providerOverride: providerOverride
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.appendText(`‚úÖ Started session with recipe "${result.recipe?.name || recipeName}": ${result.sessionName}\n`, 'system-message');
                        this.scrollToBottom();
                        this.clearSelectedRecipe(); // Clear selection after successful start
                    } else {
                        throw new Error(result.error);
                    }
                    
                } catch (error) {
                    console.error('Error starting session with recipe:', error);
                    this.appendText(`‚ùå Failed to start session with recipe: ${error.message}\n`, 'system-message');
                    this.scrollToBottom();
                }
            }
            
            async deleteSession(sessionName) {
                // Confirm deletion
                if (!confirm(`Are you sure you want to delete session "${sessionName}"? This action cannot be undone.`)) {
                    return;
                }
                
                try {
                    const response = await fetch('/api/goose/delete', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ sessionName })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.appendText(`‚úÖ Deleted session: ${sessionName}\\n`, 'system-message');
                        this.scrollToBottom();
                        
                        // Refresh the session list
                        this.showSessionModal();
                    } else {
                        throw new Error(result.error);
                    }
                    
                } catch (error) {
                    console.error('Error deleting session:', error);
                    this.appendText(`‚ùå Failed to delete session: ${error.message}\\n`, 'system-message');
                    this.scrollToBottom();
                }
            }
            
            // Directory Browser Methods
            async showDirectoryBrowser() {
                console.log('üî• showDirectoryBrowser called');
                this.selectedDirectory = this.currentWorkingDirectory;
                await this.loadDirectories();
                this.directoryBrowserModal.classList.add('show');
                
                // Add global click detector on the modal to debug all clicks
                console.log('üî• Adding global click detector to modal');
                this.directoryBrowserModal.addEventListener('click', (e) => {
                    console.log('üî• GLOBAL CLICK on directory modal detected:', e.target);
                    console.log('üî• Click coordinates:', e.clientX, e.clientY);
                    console.log('üî• Target element:', e.target.tagName, e.target.className, e.target.id);
                    console.log('üî• Is button?', e.target.tagName === 'BUTTON');
                });
                
                // Debug the buttons' CSS properties
                setTimeout(() => {
                    const selectBtn = document.getElementById('selectDirectoryBtn');
                    const cancelBtn = document.getElementById('cancelDirectorySelection');
                    const closeBtn = this.closeDirectoryBrowserModal;
                    
                    console.log('üî• CSS Debug - Select button computed style:');
                    if (selectBtn) {
                        const selectStyle = window.getComputedStyle(selectBtn);
                        console.log('  pointer-events:', selectStyle.pointerEvents);
                        console.log('  z-index:', selectStyle.zIndex);
                        console.log('  position:', selectStyle.position);
                        console.log('  display:', selectStyle.display);
                        console.log('  visibility:', selectStyle.visibility);
                        console.log('  opacity:', selectStyle.opacity);
                    }
                    
                    console.log('üî• CSS Debug - Cancel button computed style:');
                    if (cancelBtn) {
                        const cancelStyle = window.getComputedStyle(cancelBtn);
                        console.log('  pointer-events:', cancelStyle.pointerEvents);
                        console.log('  z-index:', cancelStyle.zIndex);
                        console.log('  position:', cancelStyle.position);
                    }
                    
                    console.log('üî• CSS Debug - Close (X) button computed style:');
                    if (closeBtn) {
                        const closeStyle = window.getComputedStyle(closeBtn);
                        console.log('  pointer-events:', closeStyle.pointerEvents);
                        console.log('  z-index:', closeStyle.zIndex);
                        console.log('  position:', closeStyle.position);
                    }
                }, 1000);
            }
            
            hideDirectoryBrowser() {
                console.log('hideDirectoryBrowser called');
                this.directoryBrowserModal.classList.remove('show');
                this.selectedDirectory = null;
            }
            
            async loadDirectories(path = null) {
                try {
                    const url = new URL('/api/directories', window.location.origin);
                    if (path) {
                        url.searchParams.set('dir', path);
                    }
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    this.currentPath.textContent = data.currentPath;
                    this.selectedDirectory = data.currentPath; // Auto-select current directory
                    
                    this.renderDirectories(data.directories);
                } catch (error) {
                    console.error('Error loading directories:', error);
                    this.directoryBrowser.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-muted);">Failed to load directories</div>';
                }
            }
            
            renderDirectories(directories) {
                this.directoryBrowser.innerHTML = directories.map(dir => `
                    <div class="directory-item" data-path="${dir.path}">
                        <div class="directory-icon">${dir.isParent ? '‚¨ÜÔ∏è' : 'üìÅ'}</div>
                        <div>${dir.name}</div>
                    </div>
                `).join('');
                
                // Add click event listeners
                this.directoryBrowser.querySelectorAll('.directory-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const path = item.dataset.path;
                        
                        // Clear previous selection
                        this.directoryBrowser.querySelectorAll('.directory-item').forEach(i => {
                            i.classList.remove('selected');
                        });
                        
                        // Select this item
                        item.classList.add('selected');
                        this.selectedDirectory = path;
                    });
                    
                    item.addEventListener('dblclick', () => {
                        const path = item.dataset.path;
                        this.loadDirectories(path);
                    });
                });
            }
            
            
            async initializeWorkingDirectory() {
                try {
                    // Try to get the current working directory from the server
                    const response = await fetch('/api/directories');
                    const data = await response.json();
                    
                    this.currentWorkingDirectory = data.currentPath;
                    if (this.workingDirectory) {
                        this.workingDirectory.value = data.currentPath;
                        this.workingDirectory.placeholder = data.currentPath;
                    }
                    
                    // Also set wizard working directory
                    if (this.wizardWorkingDirectory) {
                        this.wizardWorkingDirectory.value = data.currentPath;
                        this.wizardWorkingDirectory.placeholder = data.currentPath;
                    }
                } catch (error) {
                    console.error('Error initializing working directory:', error);
                    // Fallback to a reasonable default message
                    if (this.workingDirectory) {
                        this.workingDirectory.placeholder = 'Click Browse to select directory';
                    }
                    if (this.wizardWorkingDirectory) {
                        this.wizardWorkingDirectory.placeholder = 'Click Browse to select directory';
                    }
                }
            }
            
            // Session Creation Wizard Methods
            startSessionWizard() {
                // Reset wizard state
                this.wizardCurrentStep = 1;
                this.wizardData = {
                    sessionName: '',
                    selectedRecipe: null,
                    workingDirectory: this.currentWorkingDirectory
                };
                
                // Copy session name from main modal if set
                this.wizardSessionName.value = this.newSessionName.value;
                this.wizardWorkingDirectory.value = this.currentWorkingDirectory || '';
                
                // Hide session modal and show wizard
                this.hideSessionModal();
                this.showWizardStep(1);
                this.sessionWizardModal.classList.add('show');
            }
            
            hideSessionWizard() {
                this.sessionWizardModal.classList.remove('show');
                this.resetWizard();
            }
            
            showWizardStep(step) {
                // Hide all steps
                this.wizardStep1.style.display = 'none';
                this.wizardStep2.style.display = 'none';
                this.wizardStep2_5.style.display = 'none';
                this.wizardStep3.style.display = 'none';
                
                // Show current step
                switch (step) {
                    case 1:
                        this.wizardStep1.style.display = 'block';
                        break;
                    case 2:
                        this.wizardStep2.style.display = 'block';
                        this.updateStep2State();
                        break;
                    case 2.5:
                        this.wizardStep2_5.style.display = 'block';
                        this.updateProviderStepDisplay();
                        break;
                    case 3:
                        this.wizardStep3.style.display = 'block';
                        break;
                }
                
                this.wizardCurrentStep = step;
            }
            
            wizardGoToStep(step) {
                // Validate current step before proceeding
                if (this.wizardCurrentStep === 1) {
                    this.wizardData.sessionName = this.wizardSessionName.value.trim();
                }
                
                if (this.wizardCurrentStep === 2) {
                    // Step 2 validation handled by button states
                }
                
                this.showWizardStep(step);
            }
            
            wizardGoToProviderStep() {
                // Only show provider step if recipe is selected
                if (this.wizardData.selectedRecipe && this.wizardData.selectedRecipe !== false) {
                    this.updateProviderStepDisplay();
                    this.showWizardStep(2.5);
                } else {
                    // Skip provider step if no recipe
                    this.wizardGoToStep(3);
                }
            }
            
            updateProviderStepDisplay() {
                // Show recipe's default provider/model
                const recipe = this.wizardData.selectedRecipe;
                const recipeProvider = recipe?.settings?.goose_provider || 'Goose Default';
                const recipeModel = recipe?.settings?.goose_model || 'Provider Default';
                
                this.recipeDefaultProvider.querySelector('span').textContent = recipeProvider;
                this.recipeDefaultModel.querySelector('span').textContent = recipeModel;
                
                // Reset override controls
                this.enableProviderOverride.checked = false;
                this.toggleProviderOverride();
            }
            
            toggleProviderOverride() {
                const enabled = this.enableProviderOverride.checked;
                this.providerOverrideControls.style.display = enabled ? 'block' : 'none';
                
                if (!enabled) {
                    this.overrideProvider.value = '';
                    this.overrideModel.value = '';
                    this.overrideModelGroup.style.display = 'none';
                }
            }
            
            updateStep2State() {
                // Enable/disable next button based on recipe selection
                const hasRecipe = this.wizardData.selectedRecipe !== null;
                const skippedRecipe = this.wizardData.selectedRecipe === false;
                
                this.wizardStep2Next.disabled = !(hasRecipe || skippedRecipe);
                
                // Update recipe display
                if (this.wizardData.selectedRecipe && this.wizardData.selectedRecipe !== false) {
                    this.wizardSelectedRecipeName.textContent = this.wizardData.selectedRecipe.name;
                    this.wizardSelectedRecipeDescription.textContent = this.wizardData.selectedRecipe.description;
                    this.selectedRecipeWizard.style.display = 'block';
                } else {
                    this.selectedRecipeWizard.style.display = 'none';
                }
            }
            
            wizardChooseRecipe() {
                // Store wizard context and show recipe selector
                this.selectedRecipe = this.wizardData.selectedRecipe;
                this.showRecipeSelectorModal();
            }
            
            wizardSkipRecipe() {
                this.wizardData.selectedRecipe = false; // false means explicitly skipped
                this.updateStep2State();
            }
            
            wizardBrowseDirectory() {
                // Use existing directory browser
                this.showDirectoryBrowser();
            }
            
            wizardUseCurrentDirectory() {
                this.wizardData.workingDirectory = this.currentWorkingDirectory;
                this.wizardWorkingDirectory.value = this.currentWorkingDirectory || '';
            }
            
            async wizardCreateSession() {
                // Collect final data
                this.wizardData.sessionName = this.wizardSessionName.value.trim();
                this.wizardData.workingDirectory = this.wizardWorkingDirectory.value || this.currentWorkingDirectory;
                
                // Collect provider override if enabled
                let providerOverride = null;
                if (this.enableProviderOverride && this.enableProviderOverride.checked) {
                    if (this.overrideProvider.value || this.overrideModel.value) {
                        providerOverride = {
                            provider: this.overrideProvider.value || null,
                            model: this.overrideModel.value || null
                        };
                    }
                }
                
                // Store provider override for use in session creation
                this.currentProviderOverride = providerOverride;
                
                // Create session based on whether recipe was selected
                if (this.wizardData.selectedRecipe && this.wizardData.selectedRecipe !== false) {
                    await this.createSessionWithRecipe(
                        this.wizardData.sessionName,
                        this.wizardData.selectedRecipe,
                        this.wizardData.workingDirectory
                    );
                } else {
                    await this.createRegularSession(
                        this.wizardData.sessionName,
                        this.wizardData.workingDirectory
                    );
                }
                
                this.hideSessionWizard();
            }
            
            resetWizard() {
                this.wizardCurrentStep = 1;
                this.wizardData = {
                    sessionName: '',
                    selectedRecipe: null,
                    workingDirectory: this.currentWorkingDirectory
                };
                this.wizardSessionName.value = '';
                this.selectedRecipeWizard.style.display = 'none';
                this.wizardStep2Next.disabled = true;
            }
            
            // Override confirmRecipe to work with wizard
            confirmRecipe() {
                if (this.currentPreviewRecipe) {
                    if (this.sessionWizardModal.classList.contains('show')) {
                        // Wizard mode
                        this.wizardData.selectedRecipe = this.currentPreviewRecipe;
                        this.updateStep2State();
                    } else {
                        // Original mode
                        this.selectedRecipe = this.currentPreviewRecipe;
                        this.updateSelectedRecipeDisplay();
                    }
                    this.hideRecipeSelectorModal();
                }
            }
            
            // Override confirmDirectorySelection to work with wizard
            confirmDirectorySelection() {
                console.log('confirmDirectorySelection called, selectedDirectory:', this.selectedDirectory);
                if (this.selectedDirectory) {
                    if (this.sessionWizardModal.classList.contains('show')) {
                        // Wizard mode
                        console.log('Setting wizard working directory:', this.selectedDirectory);
                        this.wizardData.workingDirectory = this.selectedDirectory;
                        this.wizardWorkingDirectory.value = this.selectedDirectory;
                    } else {
                        // Original mode
                        console.log('Setting regular working directory:', this.selectedDirectory);
                        if (this.workingDirectory) {
                            this.workingDirectory.value = this.selectedDirectory;
                        }
                        this.currentWorkingDirectory = this.selectedDirectory;
                    }
                    this.hideDirectoryBrowser();
                } else {
                    console.log('No directory selected');
                }
            }
            
            async createSessionWithRecipe(sessionName, recipe, workingDirectory) {
                try {
                    const parameters = {}; // Could collect from recipe parameters in future
                    
                    const response = await fetch('/api/goose/start-with-recipe', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            recipeId: recipe.id,
                            sessionName: sessionName || undefined,
                            parameters,
                            workingDirectory
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.appendText(`‚úÖ Started session with recipe "${recipe.name}": ${result.sessionName}\n`, 'system-message');
                        this.scrollToBottom();
                    } else {
                        throw new Error(result.error);
                    }
                    
                } catch (error) {
                    console.error('Error starting session with recipe:', error);
                    this.appendText(`‚ùå Failed to start session with recipe: ${error.message}\n`, 'system-message');
                    this.scrollToBottom();
                }
            }
            
            async createRegularSession(sessionName, workingDirectory) {
                try {
                    const response = await fetch('/api/goose/start', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            sessionName: sessionName || undefined,
                            builtins: ['developer'],
                            workingDirectory
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.appendText(`‚úÖ Started new session: ${result.sessionName}\n`, 'system-message');
                        this.scrollToBottom();
                    } else {
                        throw new Error(result.error);
                    }
                    
                } catch (error) {
                    console.error('Error starting new session:', error);
                    this.appendText(`‚ùå Failed to start new session: ${error.message}\n`, 'system-message');
                    this.scrollToBottom();
                }
            }
        }
        
        // Initialize the app
        new GooseStreamingApp();
    </script>
</body>
</html>